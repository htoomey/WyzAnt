                              Numerical Analysis
                                Algorithms in C
                                  Version 4.2
                                 User's Manual






                                      For
                     "Numerical Analysis", fourth edition
                    Richard L. Burden and J. Douglas Faires
                                     1988






                                  Written by:
                            Harold A. Toomey, MSEE
                              Care-Free Software
                               3rd Quarter 1991


 
Technical Publications:
Harold A. Toomey

Programming:
Harold A. Toomey

 
(C) Copyright 1988-1993, Harold A. Toomey - All rights reserved

This document contains proprietary information of Harold A. Toomey and
is protected by Federal copyright law.  The information may not be
disclosed to third parties or copied or duplicated in any form, in
whole or in part, without prior written consent of Harold A. Toomey. 
Limited rights exist for individual and university site licenses.  The
software may be used or copied only in accordance with the terms of
the license agreement.  Students may copy this software with the
intent to join the $20.00 Club, paying for the right to use this
software.  See the sample license agreements in this document.

The information in this document is subject to change without notice.


"Numerical Analysis Algorithms in C" User's Manual
Version 4.2
Document Number 9307-42C-UM2

Care-Free Software
Attn: Harold Allen Toomey
464 North 750 East
Lindon, UT  84042
1-801-785-0464


IBM is a trademark of International Business Machines Corporation.
Microsoft and MS-DOS are registered trademarks.
UNIX is a registered trademark of AT&T Bell Laboratories.
VAX and VMS are registered trademarks of Digital Equipment
Corporation.
                 This collection of C programs is
                  dedicated to my wife, Holly and to my
                  son, David.  They gave me the privacy
                  I needed to program, and they listened
                  attentively, sharing my enthusiasm,
                  whenever I expounded on what I had
                  programmed˛even though they hadn't the
                  foggiest idea what I was talking
                  about.


PREFACE


About the Author

Harold A. Toomey, M.S. in Electrical and Computer Engineering, is
currently a Software Engineer at Novell in Provo, Utah.  While minoring
in mathematics at Brigham Young University, he tutored students in
calculus, then tutored C programming at BYU's Electrical Engineering
Department.  Not content with the provided FORTRAN algorithms while
taking several numerical methods courses, he began coding numerical
algorithms in C.  The introductory text used for these numerical
analysis courses was "Numerical Analysis."


History of "Numerical Analysis Algorithms in C"

BYU's mathematics department expressed an interest in having all of
the algorithms found in the "Numerical Analysis" text programmed in C,
along with a few of their favorites still in FORTRAN.  Version 3.0 was
finally completed in December 1988.  BYU was the first university to
purchase a university site license.  This software is being used for
their numerical methods courses today and has been tested by hundreds
of students.  Their input has resulted in several other versions,
culminating into version 4.2.  Version 4.0 became necessary for the
fourth edition of the "Numerical Analysis" text.  Since 1988, several
universities and scores of students have purchased these programs to
be used in college course work and on the job.  See the file
"revhist.doc" (for revision history) for a complete overview of the
history of "Numerical Analysis Algorithms in C."


Acknowledgements

The author would like to express his appreciation to the many
individuals who made suggestions for improvement on the previous
versions of these algorithms.  These include the professor who gave
directions for the first version: G. S. Gill, Brigham Young University
(also a reviewer for the third edition of the text), and Bruce
Cardwell who supervises the Numerical Analysis Laboratory also at
Brigham Young University.  Special thanks also go to Jay Lawlor, M.S.
Electrical Engineering, for giving timely feedback while using the
algorithms for a numerical methods class at BYU.  In particular,
thanks also goes to Holly Z. Toomey for typesetting previous versions
of the Examples Book.



CONTENTS


PREFACE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  -iv-

1. Introduction. . . . . . . . . . . . . . . . . . . . . . . . . . . . .   1-1
   1.1  Getting Started. . . . . . . . . . . . . . . . . . . . . . . . .   1-1
   1.2  Purpose of the Programs. . . . . . . . . . . . . . . . . . . . .   1-2
   1.3  For Instructors. . . . . . . . . . . . . . . . . . . . . . . . .   1-2
        1.3.1 "Numerical Analysis" Authors' Recommendations. . . . . . .   1-2
        1.3.2 Homework Helpers . . . . . . . . . . . . . . . . . . . . .   1-2
        1.3.3 Modifying Programs . . . . . . . . . . . . . . . . . . . .   1-3
        1.3.4 Intentionally Introducing Errors . . . . . . . . . . . . .   1-3
   1.4  Product Support. . . . . . . . . . . . . . . . . . . . . . . . .   1-3

2. Installation. . . . . . . . . . . . . . . . . . . . . . . . . . . . .   2-1
   2.1  Basic Installation Procedures. . . . . . . . . . . . . . . . . .   2-1
   2.2  Uploading to Mainframe Computers . . . . . . . . . . . . . . . .   2-2

3. "Numerical Analysis Algorithms in C" Files. . . . . . . . . . . . . .   3-1
   3.1  Algorithm Files. . . . . . . . . . . . . . . . . . . . . . . . .   3-1
   3.3  Supporting C Source Code . . . . . . . . . . . . . . . . . . . .   3-5
   3.4  Documentation Files. . . . . . . . . . . . . . . . . . . . . . .   3-6
   3.5  Utility Files. . . . . . . . . . . . . . . . . . . . . . . . . .   3-6
   3.6  Batch, Script and Command Files. . . . . . . . . . . . . . . . .   3-7
   3.7  File Structure Chart . . . . . . . . . . . . . . . . . . . . . .   3-8
   3.8  File Name Translation Table from 3rd to 4th Edition. . . . . . .   3-8
   3.9  4th Edition Differences. . . . . . . . . . . . . . . . . . . . .   3-9

4. Step-By-Step Examples on Various Computers. . . . . . . . . . . . . .   4-1
   4.1  Need List. . . . . . . . . . . . . . . . . . . . . . . . . . . .   4-1
   4.2  Customizing Naautil.c. . . . . . . . . . . . . . . . . . . . . .   4-1
   4.3  Example Using MS-DOS, Microsoft C and the P-Edit Editor. . . . .   4-2
   4.4  Example Using UNIX, cc and the vi Editor . . . . . . . . . . . .   4-5
   4.5  Example Using a Macintosh and THINK C. . . . . . . . . . . . . .   4-8
   4.6  Example Using VAX/VMS, CC and the EDIT/EDT Editor. . . . . . . .  4-12

5. For Those New to C. . . . . . . . . . . . . . . . . . . . . . . . . .   5-1
   5.1  Mathematical Operators . . . . . . . . . . . . . . . . . . . . .   5-1
   5.2  Mathematical Functions . . . . . . . . . . . . . . . . . . . . .   5-2
   5.3  General Language Hints . . . . . . . . . . . . . . . . . . . . .   5-6
   5.4  Language Transition Kit. . . . . . . . . . . . . . . . . . . . .   5-7

6. Helps and Hints . . . . . . . . . . . . . . . . . . . . . . . . . . .   6-1
   6.1  Generally Nice To Know . . . . . . . . . . . . . . . . . . . . .   6-1
        6.1.1 Professor's Favorites, Must Have, Algorithms . . . . . . .   6-1
        6.1.2 Homework Helper Algorithms . . . . . . . . . . . . . . . .   6-1
        6.1.3 Optional Title . . . . . . . . . . . . . . . . . . . . . .   6-1
        6.1.4 Optional File Saving . . . . . . . . . . . . . . . . . . .   6-2
        6.1.5 Finding Functions. . . . . . . . . . . . . . . . . . . . .   6-2
        6.1.6 Using Default Inputs . . . . . . . . . . . . . . . . . . .   6-2
        6.1.7 Changing Arithmetic Precision. . . . . . . . . . . . . . .   6-2
        6.1.8 Using Floating-Point Numbers in Functions. . . . . . . . .   6-3
        6.1.9 The Pow() Function . . . . . . . . . . . . . . . . . . . .   6-4
        6.1.10Implementing SIG-Digit Rounding/Truncation . . . . . . . .   6-4
        6.1.11Floating-Point Output Alignment. . . . . . . . . . . . . .   6-5
   6.2  Converting Programs into Functions . . . . . . . . . . . . . . .   6-5
        6.2.1 An Example Using Simpson's Rule. . . . . . . . . . . . . .   6-7
   6.3  Using Input Files (*.IN) . . . . . . . . . . . . . . . . . . . .   6-8
   6.4  Using Output Files (*.OUT) . . . . . . . . . . . . . . . . . . .  6-10
   6.5  Explanation of the Naautil.c File. . . . . . . . . . . . . . . .  6-10
        6.5.1 #Define Flags. . . . . . . . . . . . . . . . . . . . . . .  6-10
        6.5.2 Flag Default Settings. . . . . . . . . . . . . . . . . . .  6-11
        6.5.3 Description of the Routines. . . . . . . . . . . . . . . .  6-12
   6.6  Using Naautil.c as Object Code . . . . . . . . . . . . . . . . .  6-14
        6.6.1 MS-DOS . . . . . . . . . . . . . . . . . . . . . . . . . .  6-15
        6.6.2 UNIX . . . . . . . . . . . . . . . . . . . . . . . . . . .  6-15
        6.6.3 Macintosh. . . . . . . . . . . . . . . . . . . . . . . . .  6-15
        6.6.4 VAX/VMS. . . . . . . . . . . . . . . . . . . . . . . . . .  6-16
   6.7  Supporting C Source Code Usage List. . . . . . . . . . . . . . .  6-16
   6.8  "Numerical Analysis" Text Errors and Corrections . . . . . . . .  6-17
        6.8.1 3rd Edition Errors . . . . . . . . . . . . . . . . . . . .  6-17
        6.8.2 4th Edition Errors . . . . . . . . . . . . . . . . . . . .  6-18
   6.9  Watch for These Run-Time Errors. . . . . . . . . . . . . . . . .  6-20
        6.9.1 Stack Space. . . . . . . . . . . . . . . . . . . . . . . .  6-20
        6.9.2 Division By Zero . . . . . . . . . . . . . . . . . . . . .  6-20
        6.9.3 Null Pointer Assignments . . . . . . . . . . . . . . . . .  6-20
        6.9.4 No Disk Space. . . . . . . . . . . . . . . . . . . . . . .  6-21
        6.9.5 Floating-Point Accuracy. . . . . . . . . . . . . . . . . .  6-21
        6.9.6 Program Stuck in an Infinite Loop. . . . . . . . . . . . .  6-21

7. Useful Utilities. . . . . . . . . . . . . . . . . . . . . . . . . . .   7-1
   7.1  Convert.c - Converting Files from Extended ASCII to Standard ASCII  7-1
        7.1.1 Why Convert.c is Needed. . . . . . . . . . . . . . . . . .   7-1
        7.1.2 How to Use Convert.c . . . . . . . . . . . . . . . . . . .   7-2
   7.2  List.com - A Better TYPE Command . . . . . . . . . . . . . . . .   7-3
   7.3  Time-Saving Batch, Script and Command Files. . . . . . . . . . .   7-3
        7.3.1 CC.BAT . . . . . . . . . . . . . . . . . . . . . . . . . .   7-3
        7.3.2 CCC. . . . . . . . . . . . . . . . . . . . . . . . . . . .   7-5
        7.3.3 VAXCC.COM. . . . . . . . . . . . . . . . . . . . . . . . .   7-6

8. The Equation Evaluator Routines . . . . . . . . . . . . . . . . . . .   8-1
   8.1  What the Routines Do . . . . . . . . . . . . . . . . . . . . . .   8-1
   8.2  How to Insert the Routines into a Program. . . . . . . . . . . .   8-1
   8.3  An Example Using Simpson's Rule. . . . . . . . . . . . . . . . .   8-2
   8.4  Using Eqeval.c As Pre-Compiled Object Code . . . . . . . . . . .   8-2
   8.5  Valid Math Operators and Functions . . . . . . . . . . . . . . .   8-3
   8.6  Sample Equations . . . . . . . . . . . . . . . . . . . . . . . .   8-4
   8.7  Possible Error Messages. . . . . . . . . . . . . . . . . . . . .   8-4
   8.8  List of Algorithms Using the Equation Evaluator Routines . . . .   8-5
   8.9  Limitations. . . . . . . . . . . . . . . . . . . . . . . . . . .   8-6
   8.10 Trade-Offs . . . . . . . . . . . . . . . . . . . . . . . . . . .   8-6

9. Portability . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   9-1
   9.1  C vs ANSI C. . . . . . . . . . . . . . . . . . . . . . . . . . .   9-2
   9.2  IBM PCs and MS-DOS . . . . . . . . . . . . . . . . . . . . . . .   9-3
   9.3  UNIX Workstations. . . . . . . . . . . . . . . . . . . . . . . .   9-3
   9.4  Macintosh Computers. . . . . . . . . . . . . . . . . . . . . . .   9-4
   9.5  VAX Mainframes . . . . . . . . . . . . . . . . . . . . . . . . .   9-5
   9.6  Tested Compilers . . . . . . . . . . . . . . . . . . . . . . . .   9-5

10.     Sample License Agreements. . . . . . . . . . . . . . . . . . . .  10-1
   10.1       Individual License Sample. . . . . . . . . . . . . . . . .  10-1
   10.2       University/Corporation Site License Sample . . . . . . . .  10-3

11.     Packaging Information. . . . . . . . . . . . . . . . . . . . . .  11-1
   11.1       MS-DOS Diskettes . . . . . . . . . . . . . . . . . . . . .  11-1
        11.1.15¨" 1.2M High Density Diskettes. . . . . . . . . . . . . .  11-1
        11.1.25¨" 360K Low Density Diskettes . . . . . . . . . . . . . .  11-2
        11.1.33´" 1.44M High Density Diskettes . . . . . . . . . . . . .  11-2
        11.1.43´" 720K Low Density Diskettes . . . . . . . . . . . . . .  11-2
   11.2       Macintosh Diskettes. . . . . . . . . . . . . . . . . . . .  11-2
        11.2.13´" 800K Macintosh Diskettes . . . . . . . . . . . . . . .  11-3

12.     Purchasing Information . . . . . . . . . . . . . . . . . . . . .  12-1
   12.1       $20.00 Club. . . . . . . . . . . . . . . . . . . . . . . .  12-1
   12.2       Order Form . . . . . . . . . . . . . . . . . . . . . . . .  12-1

References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-2

Appendix A:   C Source Code for 041.C. . . . . . . . . . . . . . . . . .   A-1

Appendix B:   C Source Code for NAAUTIL.C. . . . . . . . . . . . . . . .   B-1

Appendix C:   Language Comparison Charts . . . . . . . . . . . . . . . .   C-1
   C.1  C vs Ada . . . . . . . . . . . . . . . . . . . . . . . . . . . .   C-2
   C.2  C vs BASIC . . . . . . . . . . . . . . . . . . . . . . . . . . .   C-8
   C.3  C vs C++ . . . . . . . . . . . . . . . . . . . . . . . . . . . .  C-13
   C.4  C vs FORTRAN 77. . . . . . . . . . . . . . . . . . . . . . . . .  C-14
   C.5  C vs Pascal. . . . . . . . . . . . . . . . . . . . . . . . . . .  C-20

Appendix D:   Sample Programs in Other Languages . . . . . . . . . . . .   D-1
   D.1  Ada. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   D-2
        D.1.1 SIMPSON.ADA. . . . . . . . . . . . . . . . . . . . . . . .   D-2
        D.1.2 NAAUTIL.ADA. . . . . . . . . . . . . . . . . . . . . . . .   D-5
        D.1.3 SIMPSON.IN . . . . . . . . . . . . . . . . . . . . . . . .   D-7
        D.1.4 SIMPSON.OUT. . . . . . . . . . . . . . . . . . . . . . . .   D-7
   D.2  BASIC. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   D-9
        D.2.1 SIMPSON.BAS. . . . . . . . . . . . . . . . . . . . . . . .   D-9
        D.2.2 SIMPSON.IN . . . . . . . . . . . . . . . . . . . . . . . .  D-11
        D.2.3 SIMPSON.OUT. . . . . . . . . . . . . . . . . . . . . . . .  D-11
   D.3  C. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  D-13
        D.3.1 SIMPSON.C. . . . . . . . . . . . . . . . . . . . . . . . .  D-13
        D.3.2 NAAUTIL.H. . . . . . . . . . . . . . . . . . . . . . . . .  D-15
        D.3.3 SIMPSON.IN . . . . . . . . . . . . . . . . . . . . . . . .  D-18
        D.3.4 SIMPSON.OUT. . . . . . . . . . . . . . . . . . . . . . . .  D-18
   D.4  C++. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  D-19
        D.4.1 SIMPSON.CPP. . . . . . . . . . . . . . . . . . . . . . . .  D-19
        D.4.2 NAAUTIL.HPP. . . . . . . . . . . . . . . . . . . . . . . .  D-21
        D.4.3 SIMPSON.IN . . . . . . . . . . . . . . . . . . . . . . . .  D-23
        D.4.4 SIMPSON.OUT. . . . . . . . . . . . . . . . . . . . . . . .  D-23
   D.5  FORTRAN 77 . . . . . . . . . . . . . . . . . . . . . . . . . . .  D-25
        D.5.1 SIMPSON.FOR. . . . . . . . . . . . . . . . . . . . . . . .  D-25
        D.5.2 SIMPSON.IN . . . . . . . . . . . . . . . . . . . . . . . .  D-27
        D.5.3 SIMPSON.OUT. . . . . . . . . . . . . . . . . . . . . . . .  D-28
   D.6  Pascal . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  D-29
        D.6.1 SIMPSON.PAS. . . . . . . . . . . . . . . . . . . . . . . .  D-29
        D.6.2 NAAUTIL.INC. . . . . . . . . . . . . . . . . . . . . . . .  D-32
        D.6.3 NAAMATH.INC. . . . . . . . . . . . . . . . . . . . . . . .  D-33
        D.6.4 SIMPSON.IN . . . . . . . . . . . . . . . . . . . . . . . .  D-33
        D.6.5 SIMPSON.OUT. . . . . . . . . . . . . . . . . . . . . . . .  D-34

INDEX. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   -i-



1.   Introduction


"Numerical Analysis Algorithms in C" contains 116 stand-alone programs
implementing the algorithms found in the texts:

                "Numerical Analysis", third and fourth edition,
                 Richard L. Burden & J. Douglas Faires, 1988.

Each program is written in ANSI C to make them more portable to other
computer systems.  They should run on any computer with a reasonable C
compiler, such as IBM PCs, UNIX workstations, VAXes, and Macintoshes.

The "Numerical Analysis" text, hereafter referred to as "the text",
covers the following numerical topics:

    Chapter 1     - Mathematical Preliminaries
    Chapter 2     - Solutions of equations in one variable
    Chapter 3     - Interpolation and polynomial approximation
    Chapter 4     - Numerical differentiation and integration
    Chapter 5     - Initial-value problems for ordinary differential
                  equations
    Chapter 6     - Direct methods for solving linear systems
    Chapter 7     - Iterative techniques in matrix algebra
    Chapter 8     - Approximation theory
    Chapter 9     - Approximating eigenvalues
    Chapter 10    - Numerical solutions of nonlinear systems of
                  equations
    Chapter 11    - Boundary-value problems for ordinary differential
                  equations
    Chapter 12    - Numerical solutions to partial differential
                  equations
 
From these topics, "Numerical Analysis Algorithms in C" has programmed
routines for: vector and matrix manipulation, linear equations (LU
decomposition/backsolving, matrix inversion, etc.), matrix/vector
norms, eigenvalue/vectors, complex number and polynomial manipulation,
least-square polynomial approximation, FFTs, numerical integration,
root finding, solution of nonlinear equations, Taylor polynomial
approximation, cubic splines, derivatives, ordinary and partial
differentiation.

This User's Manual will help you to use these programs to their
fullest potential.  It will walk you through an example, tutor you if
you are unfamiliar with the C language, introduce you to several
useful utilities, and assist you when running these programs on
different computer systems.


1.1  Getting Started

To install "Numerical Analysis Algorithms in C" onto your computer
system, see Chapter 2 - "Installation."  If you are new to the C
programming language, you may wish to read through Chapter 5 - "For
Those New to C."  If you want a detailed example using various C
compilers and operating systems, see Chapter 4 - "Step-By-Step
Examples on Various Computer Systems."

This software package contains about 1.5M bytes of files.  If disk
space is limited, then just copy the eight supporting ".c" files
("complex.c", "eqeval.c", "gaussj.c", "naautil.c", "naautil2.c",
"naautil3.c", "round.c" and "trunc.c") and the desired algorithms onto
your disk.  The eight supporting files require about 100K of disk
space.  If you are running these algorithms from a floppy disk, be
sure to leave the write protect tab off so the programs can save their
output to a file.  If this is undesirable, see Sub-Section 6.1.4 -
"Optional File Saving."

If you feel comfortable with C, go ahead and compile and run an
algorithm.  The source code is very readable and user friendly.  To
see what the algorithm numbers correspond to, see Section 3.1 -
"Algorithm Files."  This is the most important list in this manual and
should be printed out for frequent reference.  Section 3.1 is also
given in the file "readme.doc" for your convenience.


1.2  Purpose of the Programs

These programs are fast, but are not optimized for speed.  As stated
by the authors in the text's preface:

         "Although the algorithms will lead to correct programs
         for the examples and exercises in the text, it must be
         emphasized that there has been no attempt to write
         general-purpose software.  In particular, the
         algorithms have not always been listed in the form
         that leads to the most efficient program in terms of
         either time or storage requirements."

The purpose of these programs is to teach students numerical methods,
not programming and optimization skills.  For a good book of general-
purpose mathematical software, see the book "Numerical Recipes in C"
listed in the references.  These programs can also be used as a tool
for building other programs.  Once the algorithms are understood, they
can be more easily enhanced for general-purpose applications.


1.3  For Instructors

This software package is intended to be used by instructors of
numerical methods/analysis courses.  The best way to learn numerical
methods is to program the algorithms from scratch and have them run on
a computer.  This is a time consuming process and may take a "good"
programmer from 1 to 5 hours per program.  Students can best benefit
from these programs AFTER taking the appropriate numerical analysis
courses.


1.3.1"Numerical Analysis" Authors' Recommendations

The authors of the text "Numerical Analysis" mention in the preface
that:

         "Actual programs are not included because, in our
         experience, this encourages some students to generate
         results without fully understanding the method
         involved."

In other words, as an instructor, you may consider giving your
students only selected main algorithms, and definitely not the
"Homework Helpers" algorithms as discussed below.


1.3.2Homework Helpers

Roughly half of the included programs are labeled as "Homework
Helpers."  Most of these programs modify the given text algorithms to
satisfy the homework exercises in the text.  An example of this is
turning Algorithm 2.4 - Secant Method ("024.c") into the Method of
False Position ("024B.c").  Use these "homework helpers" to correct
homework assignments.  Do NOT just give these out to your students. 
Most modifications will take only a short time to implement, once the
algorithm is understood.


1.3.3Modifying Programs

These algorithms are given as a learning tool.  Modifying them is part
of the learning process.  These algorithms may be modified by the
instructor or by the students, even though this package is
copyrighted.  They may not, however, be altered to be resold for
profit without prior written consent from the programmer.  See the
sample licensing agreements in Chapter 10 for more details.


1.3.4Intentionally Introducing Errors

As an alternative to withholding these programs from your students,
you may wish to give them a copy with intentionally introduced errors. 
This would cause them to search the entire program over for
correctness, bridging the gap between giving too little or too much
information.


1.4  Product Support

If questions arise, ranging from getting these algorithms to work with
your compiler to adapting a particular algorithm to a specific
application, just call CARE-FREE SOFTWARE at 1-801-785-0464.  The
programmer will answer your questions at no charge other than the
normal phone charges on your monthly phone statement.  Enhancements,
recommendations and bug reports are always welcomed.


2.   Installation


2.1  Basic Installation Procedures


The "Numerical Analysis Algorithms in C" programs do not come with an
installation program.  To install these algorithms onto your computer,
do the following steps:

1.  Make a set of backup diskettes.  See your operating system manual
    for specifics.

2.  Make another set of "working" diskettes or copy the diskettes onto
    your hard disk.  All 500+ files combined require less than 1.5M
    bytes of disk space.  Only a couple of the files are required at a
    time to get the algorithms to work properly, making them useful
    even on systems without a hard disk.

3.  You may want to convert each file on the "working" disk from
    extended ASCII to standard ASCII.  This is usually required for
    Macintoshes, most UNIX computers, and VAXes.  Failure to do so may
    result in scrambled looking output characters.  Use "convert.exe",
    as explained in Section 7.1, to do this task relatively easily. 
    Macintosh disks ordered from Care-Free Software have had this step
    done already.

4.  It is recommended that the algorithms be placed in their own sub-
    directory (or Macintosh folder), such as "naa42."  This sub-
    directory can be created and entered by typing one of the
    following sets of commands:

    MS-DOS:
         C:\> MD NAA42                  - make directory
         C:\> CD NAA42                  - change directory
         C:\NAA42> DIR /P               - show directory contents

    UNIX:
         % mkdir naa42                  - make directory
         % chdir naa42                  - change directory
         % pwd                          - show current directory
         % ls -alF                      - show directory contents

    VAX/VMS:
         $ CREATE/DIR [SMITH.NAA42]     - make directory
         $ SET DEFAULT [.NAA42]         - change directory
         $ SHOW DEFAULT                 - show current directory
         $ DIR/SIZE/DATE                - show directory contents

5.  To be able to run every program from a floppy diskette, eight
    support files are required:

         complex.c         naautil.c        round.c
         eqeval.c          naautil2.c       trunc.c
         gaussj.c          naautil3.c       

    These files require about 100K bytes of disk space.  The desired
    algorithm files such as "041.c" are also needed.  The majority of
    the algorithms need only "naautil.c" which is about 20K bytes
    large.

6.  If the programs do not compile correctly, you may need to change
    some flags inside the "naautil.c" file.  Use your text editor to
    modify this file.  The contents of "naautil.c" should be self-
    documenting.  These flags are defined near the top of the file. 
    See Section 6.5 - "Explanation of the Naautil.c File" if more
    detailed information is desired.

    In the event that nothing seems to be working, you can set both
    the EQ_EVAL and the FILE_SAVE flags to FALSE.  This will disable
    the options to save the output to a file and to use the Equation
    Evaluator routines, but the algorithms will usually work.  These
    two options use variable length argument lists, which may not work
    on older compilers.

7.  If all else fails, ask another C programmer for help or call CARE-
    FREE SOFTWARE for free technical support.


2.2  Uploading to Mainframe Computers

To get these programs onto many workstations or mainframe computers,
communications software is usually required.  A well-supported
communications protocol is known as Kermit.  An example using Kermit
looks something like this:

NOTE:    This example uses CALL/ProComm to transfer files onto a
         VAX/UNIX workstation.

1.  Log onto the mainframe using CALL, ProComm or your favorite
    communications package.  Select kermit as the transfer protocol. 
    Use binary mode to send files containing extended ASCII
    characters.  Use ASCII mode if the files have been converted to
    standard ASCII by the "convert.exe" program.  Binary mode is
    slower than ASCII mode.  Remember that C files are case sensitive.

2.  On the mainframe, change to an appropriate directory and type:

    For a VAX, type:
         $ use kermit                       (Do NOT type "$ kermit")
         Kermit-32> set file_type binary    (or:  set file_type ascii)
         Kermit-32> receive

    For a UNIX workstation, type:
         % kermit
         Kermit-32> set binary              (or:  set ascii)
         Kermit-32> receive

3.  On your PC, immediately issue the file sending commands.

    For CALL, type:
         [F9] File Send Kermit
         File to transfer: filename

    For ProComm, type:
         [ALT] K
         2) Send
         Please enter filespec: filename

4.  Patiently wait as the file(s) are transferred to the mainframe. 
    The use of wild cards is recommended (ie - *.C instead of
    filename).

5.  Exit kermit on the mainframe.
         Kermit-32> exit
         $ logout

A host full of other issues have been left to the user, such as baud
rate, parity, stop bits, duplex, use of wild cards, etc.  These are
unique to each computer system and communications software package.

You may want to convert the files from extended ASCII to standard
ASCII (using "convert.c") before uploading them to a mainframe
computer.  If you plan to view and print your work on an IBM PC but
compile and run the algorithms on a mainframe, you may want to keep
the files in extended ASCII.

Test your preferences using Algorithm 4.1 ("041.c").  It uses three
different extended ASCII characters to form an integral sign: 'Ù', '˛'
and 'ı'.  "Convert.c" changes these three characters into standard
ASCII: '[', '|' and ']'.


3.   "Numerical Analysis Algorithms in C" Files


This software package contains 116 algorithms.  Each algorithm has
been coded as a stand-alone program.  Each program prompts for input,
executes the algorithm as described in the text "Numerical Analysis",
and prints the results.  Other math packages provide only subroutines,
requiring a programmer to insert them inside a program and either hard
code or prompt for the inputs and print the outputs.

The files are catagorized as follows, where "nnn" represent algorithm
numbers like "041" for Algorithm 4.1:

a.  nnn.C    Algorithms from the text "Numerical Analysis" fourth
             edition.  (57 total)

b.  nnnA.C   Algorithms not found in the text.  Included as "Professor
             Favorites, Must Have" as recommended by mathematics
             professors at Brigham Young University.  (6 total)

c.  nnnB.C, nnnC.C, and nnnD.C
             Algorithms included as "Homework Helpers."  Some are asked
             for in the homework exercises while others are for helping
             with important concepts covered in the text.  These can
             save hours of coding on the homework exercises.  (53
             total)

d.  *.C      NAA supporting files containing 57 functions.  (8 total)

e.  *.IN     Input files used to test each algorithm.  They match the
             inputs to the example problems presented after each
             algorithm in the text.  (116 total)

f.  *.OUT    Output files used to test each algorithm.  They match the
             outputs to the example problems presented after each
             algorithm in the text.  (116 total)

g.  *.EXE    Executable programs for each algorithm.  The default
             functions (like f(x)) are the same as those used in the
             example problems presented after each algorithm in the
             text.  These programs must be purchased separately and are
             currently available only for MS-DOS and Macintosh
             computers.  (116 total)

h.  *.DOC    Documentation in simple text file format.  Includes
             "readme.doc", "revhist.doc" and "usersman.doc."

Each program was tested on the sample problems given in the text just
after the algorithm description.  These sample solutions are found in
the OUT sub-directory in files named with a ".out" extension.  Their
inputs are found in the IN sub-directory in files named with a ".in"
extension.

Over two-thirds of the algorithms need to be compiled only once.  They
are marked with an asterisk (*) on the table below.  Of these
algorithms, nearly half are able to prompt you for an equation during
run-time.  See Chapter 8 - "The Equation Evaluator Routines" for more
details.


3.1  Algorithm Files

 
CHAPTER 1   Mathematical Preliminaries
 

COMPLEX.C   - "Numerical Recipes in C" Complex Number Routines
EQEVAL.C    - Equation Evaluator Routines
GAUSSJ.C    - "Numerical Recipes in C" Gauss-Jordan Matrix Solver
NAAUTIL.C   - "Numerical Analysis Algorithms in C" Utilities I(standard)
NAAUTIL2.C  - "Numerical Analysis Algorithms in C" Utilities II(extended)
NAAUTIL3.C  - "Numerical Analysis Algorithms in C" Utilities III(complex)
ROUND.C     - Rounds a floating-point value to SIG significant digits
TRUNC.C     - Truncates a floating-point value to SIG significant digits
011B.C*     - Taylor Polynomial Approximation                 Algorithm 1.1B

 
CHAPTER 2   Solutions of Equations in One Variable
 

021.C*      -  Bisection (or Binary-Search)                   Algorithm 2.1
022.C*      -  Fixed-Point                                    Algorithm 2.2
023.C       -  Newton-Raphson                                 Algorithm 2.3
024.C*      -  Secant                                         Algorithm 2.4
024B.C*     -  Method of False Position (or Regula Falsi)     Algorithm 2.4B
024C.C      -  Modified Newton-Raphson Method                 Algorithm 2.4C
025.C*      -  Steffensen                                     Algorithm 2.5
026.C*      -  Horner                                         Algorithm 2.6
027.C*      -  MÅller                                         Algorithm 2.7
028A.C*     +  Complex Polynomial Solver (CPOLY)              Algorithm 2.8A

 
CHAPTER 3   Interpolation and Polynomial Approximation
 

031.C*      -  Neville's Iterated Interpolation               Algorithm 3.1
031B.C*     -  Neville's Iterated Interpolation (with rounding)Algorithm 3.1B
031C.C*     -  Aitken's Iterated Interpolation                Algorithm 3.1C
032.C*      -  Newton's Interpolatory Divided-Difference FormulaAlgorithm 3.2
033.C*      -  Hermite Interpolation                          Algorithm 3.3
034.C*      -  Natural Cubic Spline                           Algorithm 3.4
035.C*      -  Clamped Cubic Spline                           Algorithm 3.5

 
CHAPTER 4   Numerical Differentiation and Integration
 

040B1.C     -  1st Derivative Approximation (for functions)   Algorithm 4.0B1
040B2.C*    -  1st Derivative Approximation (for tabulated data)Algorithm 4.0B2
040B3.C     -  1st Derivative Approximation (for functions w/TOL)Algorithm 4.0B3
040C1.C     -  2nd Derivative Approximation (for functions)   Algorithm 4.0C1
040C2.C*    -  2nd Derivative Approximation (for tabulated data)Algorithm 4.0C2
040D1.C*    -  Richardson's Extrapolation                     Algorithm 4.0D1
040D2.C*    -  Richardson's Extrapolation (with rounding)     Algorithm 4.0D2
041.C*      -  Composite Simpson's Rule                       Algorithm 4.1
041B.C*     -  Composite Trapezoidal Rule                     Algorithm 4.1B
041C.C*     -  Composite Midpoint Rule                        Algorithm 4.1C
041D.C*     -  Newton-Cotes Formulas for Integrals (8 total)  Algorithm 4.1D
042.C*      -  Adaptive Quadrature                            Algorithm 4.2
043.C*      -  Romberg                                        Algorithm 4.3
043B.C*     -  Gaussian Quadrature                            Algorithm 4.3B
044.C       -  Composite Simpson's Rule for Double Integrals  Algorithm 4.4
044B.C      -  Composite Trapezoid Rule for Double Integrals  Algorithm 4.4B
044C.C      -  Gaussian Quadrature for Double Integrals       Algorithm 4.4C
045.C       -  Composite Simpson's Rule for Triple Integrals  Algorithm 4.5
045B.C      -  Composite Trapezoid Rule for Triple Integrals  Algorithm 4.5B
045C.C      -  Gaussian Quadrature for Triple Integrals       Algorithm 4.5C

 
CHAPTER 5   Initial-Value Problems for Ordinary Differential Equations
 

051.C*      -  Euler                                          Algorithm 5.1
051B.C*     -  Midpoint, Modified Euler, and Heun's Methods   Algorithm 5.1B
052.C*      -  Runge-Kutta (Order Four)                       Algorithm 5.2
053.C       -  Runge-Kutta-Fehlberg                           Algorithm 5.3
054.C*      -  Adam's Fourth-Order Predictor-Corrector        Algorithm 5.4
054B.C*     -  Adams-Bashforth (all four) and Milne's Methods Algorithm 5.4B
054C.C*     -  Milne-Simpson Predictor-Corrector              Algorithm 5.4C
055.C*      -  Adam's Variable Step-Size Predictor-Corrector  Algorithm 5.5
056.C*      +  Extrapolation                                  Algorithm 5.6
057.C       -  Runge-Kutta for Systems of Differential EquationsAlgorithm 5.7
057B.C      -  Euler's Variable Step-Size for Systems         Algorithm 5.7B
058.C       -  Trapezoidal with Newton Iteration              Algorithm 5.8

 
CHAPTER 6   Direct Methods for Solving Linear Systems
 

060B.C*     -  Matrix Inverter                                Algorithm 6.0B
060C.C*     -  Determinant of a Matrix                        Algorithm 6.0C
060D.C*     -  Matrix Multiplier                              Algorithm 6.0D
061.C*      -  Gaussian Elimination with Backward SubstitutionAlgorithm 6.1
061B.C*     -  Gaussian Elimination with Backward SubstitutionAlgorithm 6.1B  
               (with rounding)
061C1.C*    - Gauss-Jordan Method                             Algorithm 6.1C1
061C2.C*    - Gauss-Jordan Method (with rounding)             Algorithm 6.1C2
061D1.C*    - Gaussian-Elimination - Gauss-Jordan Hybrid MethodAlgorithm 6.1D1
061D2.C*    - Gaussian-Elimination - Gauss-Jordan Hybrid MethodAlgorithm 6.1D2
              (with rounding)
062.C*      -  Gaussian Elimination with Maximal Column PivotingAlgorithm 6.2
062B.C*     -  Gaussian Elimination with Maximal Column PivotingAlgorithm 6.2B
               (with rounding)
063.C*      -  Gaussian Elimination with Scaled Column PivotingAlgorithm 6.3
063B.C*     -  Gaussian Elimination with Scaled Column PivotingAlgorithm 6.3B
               (with rounding)
064.C*      -  Direct Factorization                           Algorithm 6.4
064B.C*     -  Direct Factorization which solves AX=B         Algorithm 6.4B
064C.C*     -  Direct Factorization with Maximal Column PivotingAlgorithm 6.4C
               (3rd edition)
065.C*      -  LDLt Factorization                             Algorithm 6.5
065B.C*     -  LDLt Factorization which solves AX=B           Algorithm 6.5B
066.C*      -  Choleski                                       Algorithm 6.6
066B.C*     -  Choleski which solves AX=B                     Algorithm 6.6B
067.C*      -  Crout Reduction for Tridiagonal Linear Systems Algorithm 6.7

 
CHAPTER 7   Iterative Techniques in Matrix Algebra
 

070B.C*     -  Vector and Matrix Norms                        Algorithm 7.0B
071.C*      -  Jacobi Iterative                               Algorithm 7.1
072.C*      -  Gauss-Seidel Iterative                         Algorithm 7.2
073.C*      -  Successive Over Relaxation (SOR)               Algorithm 7.3
074.C*      -  Iterative Refinement (with rounding)           Algorithm 7.4
074B.C*     -  Iterative Refinement (single-precision)        Algorithm 7.4B

 
CHAPTER 8   Approximation Theory
 

080B.C*     -  Least-Squares Polynomial Approximation         Algorithm 8.0B
081.C*      +  Fast Fourier Transformation                    Algorithm 8.1

 
CHAPTER 9   Approximating Eigenvalues
 

091.C*      -  Power Method                                   Algorithm 9.1
091B.C*     -  Power Method with Aitken's Delta2 Method       Algorithm 9.1B
092.C*      -  Symmetric Power Method                         Algorithm 9.2
093.C*      -  Inverse Power Method                           Algorithm 9.3
094.C*      -  Wielandt's Deflation                           Algorithm 9.4
094B.C*     -  Wielandt's Deflation using Power Method for lambda1Algorithm 9.4B
O095.C*     -  Householder Method                             Algorithm 9.5
095B.C*     -  Householder Method (3rd edition)               Algorithm 9.5B
095C.C*     -  Householder Method for Non-Symmetric Matrices  Algorithm 9.5C
               (Upper Hessenberg)
095D.C*     -  Householder Method (with rounding)             Algorithm 9.5D
096.C*      -  QR Algorithm                                   Algorithm 9.6
096B.C*     -  QL Algorithm (3rd edition)                     Algorithm 9.6B

 
CHAPTER 10  Numerical Solutions of Nonlinear Systems of Equations
 

101.C       -  Newton's Method for Systems                    Algorithm 10.1
101A.C      -  Steffensen's Method for Systems                Algorithm 10.1A
102.C       -  Broyden's Method for Systems                   Algorithm 10.2
103.C       -  Steepest Descent Method (with F(x) and J(x))   Algorithm 10.3
103B.C      -  Steepest Descent Method (with G(x) and gradG(x))Algorithm 10.3B

 
CHAPTER 11  Boundary-Value Problems for Ordinary Differential Equations
 

111.C       -  Linear Shooting                                Algorithm 11.1
112.C       -  Nonlinear Shooting with Newton's Method        Algorithm 11.2
112B.C      -  Nonlinear Shooting with Secant Method          Algorithm 11.2B
113.C       -  Linear Finite Difference                       Algorithm 11.3
113B.C      -  Linear Finite Difference (Richardson's Extrapolation)Algorithm 11.3B
114.C       -  Nonlinear Finite Difference                    Algorithm 11.4
114B.C      -  Nonlinear Finite Difference (Richardson's Extrapolation)Algorithm 11.4B
115.C       -  Piecewise Linear Rayleigh-Ritz                 Algorithm 11.5
116.C       -  Cubic Spline Rayleigh-Ritz                     Algorithm 11.6

 
CHAPTER 12  Numerical Solutions to Partial-Differential Equations
 

121.C       -  Poisson Equation Finite-Difference (Elliptic)  Algorithm 12.1
122.C*      -  Heat Equation Backward-Difference (Parabolic)  Algorithm 12.2
122B.C*     -  Heat Equation Forward-Difference (Parabolic)   Algorithm 12.2B
122C.C*     -  Heat Equation Richardson's Method (Parabolic)  Algorithm 12.2C
123.C*      -  Crank-Nicolson (Parabolic)                     Algorithm 12.3
124.C       -  Wave Equation Finite-Difference (Hyperbolic)   Algorithm 12.4
125.C       -  Finite-Element                                 Algorithm 12.5
126A.C      -  Parabolic Equations With Newton Iteration in 1-DAlgorithm 12.6A
127A.C      -  Parabolic Equations With Newton Iteration in 2-DAlgorithm 12.7A
128A.C      -  Elliptic Equations With Newton Iteration in 2-DAlgorithm 12.8A
129A.C      -  Biharmonic Equation Using Gauss-Jordan Method  Algorithm 12.9A

The '+'s above mean the program may need a larger stack when compiled
and linked.
The '*'s above mean the program needs to be compiled only once.


3.3  Supporting C Source Code

The eight files below are needed to compile each and every program. 
Most algorithms require only one or two of them at a time.

COMPLEX.C
    "Complex.c" contain several routines for operating on complex
    numbers.  It originated from the book "Numerical Recipes in C" and
    is only used in "naautil3.c."

EQEVAL.C
    "Eqeval.c" contains the Equation Evaluator routines.  These
    routines enable a program to enter and evaluate an equation during
    run-time. It is useful within algorithms that need to evaluate a
    single function such as f(x) or f(y,t).  It is used by 34
    algorithms.  See Chapter 8 - "The Equation Evaluator Routines" for
    more details on this file.

GAUSSJ.C
    "Gaussj.c" is a Gauss-Jordan matrix solver routine.  It originated
    from the book "Numerical Recipes in C."  It is used by only 9 of
    the algorithms.

NAAUTIL.C
    "Naautil.c" contain important routines used by all of the
    algorithms.  Most are for dynamically allocating memory for
    arrays.  Some of the routines originated from the book "Numerical
    Recipes in C."  See Section 6.5 - "Explanation of the Naautil.c
    File."

NAAUTIL2.C
    "Naautil2.c" contains more dynamically allocated memory routines
    for less-used data types.  it is used only 2 times.

NAAUTIL3.C
    "Naautil3.c" contains more dynamically allocated memory routines
    for complex data types.  It is used only 3 times.
    
ROUND.C
    "Round.c" rounds a floating-point value to SIG significant digits. 
    Only 9 algorithms currently use this function.  See Sub-Section
    6.1.10 to see how this file is used.

TRUNC.C
    "Trunc.c" truncates, or chops, a floating-point value to SIG
    significant digits.  None of the algorithms use this function, but
    it can easily replace "round.c."


3.4  Documentation Files

Previous versions of "Numerical Analysis Algorithms in C" consisted of
only two document files: "readme.doc" and "math.doc."  With version
4.2, these documents have been consolidated and greatly expanded into
this User's Manual ("usersman.doc").  Three document files are
included as listed below.

README.DOC
    "Readme.doc" gives a list of all the algorithms as well as an
    order form.  This information can also be found inside the User's
    Manual.

REVHIST.DOC
    "Revhist.doc" gives a detailed list of all changes made to each
    version of "Numerical Analysis Algorithms in C".  It lists the
    additions, corrections, and changes made to each algorithm, to the
    supporting files, and to the documentation.

USERSMAN.DOC
    "Usersman.doc" is this User's Manual in DOS text format.  This
    format is readable by all text editors and word processors.  It
    can be read using MS-DOS's "type" command or the "list.com"
    utility included with the diskettes.


3.5  Utility Files

041EE.C
    "041ee.c" is an example of how to integrate the equation evaluator
    routines into an algorithm.

041FUN.C
    "041fun.c" is an example of Algorithm 4.1 turned into a stand-
    alone function.

CONVERT.C
    "Convert.c" is the C source code for a utility which translates
    text files into standard seven-bit ASCII files.  It is useful
    before placing these algorithms on non-MS-DOS computers, such as
    UNIX and VAX computers.  See Section 7.1 - "Convert.c - Converting
    Files from Extended ASCII to Standard ASCII."

CONVERT.EXE
    "Convert.exe" is the MS-DOS executable of "convert.c."

LISTALL
    "Listall" is a text file listing all source code files on the root
    directory of the distribution disks.  It can be used with
    "convert.exe" to convert all the programs at once.

LISTOUT
    "Listout" is a text file listing all output files in the OUT sub-
    directory of the distribution disks.  It can be used with
    "convert.exe" to convert all of the output files at once.

LIST.COM
    "List.com" is an MS-DOS program which acts as a better "TYPE"
    command.  It uses the arrow keys and other editing keys to view
    text files.  "List.com" does not allow you to edit files, just
    view them.  It is a public domain program.  See Section 7.2 -
    "List.com - A better TYPE Command" for instructions on how to use
    it.


3.6  Batch, Script and Command Files

Three commands text files are included to simplify the task of
compiling and running the algorithms on different computer systems.

CC.BAT
    "Cc.bat" is an MS-DOS batch file used for compiling, running and
    viewing a Microsoft C 5.0 program.  It can be easily altered to
    allow for linking to "naautil.c" and "eqeval.c" object files,
    speeding up the compile time.  It can also be altered to increase
    the stack size of a program.

CCC
    "Ccc" is a UNIX script file used for compiling, running, and
    viewing a C program.  It can be easily altered to allow for
    linking to "naautil.c" object code, speeding up the compile time.

VAXCC.COM
    "Vaxcc.com" is a VAX/VMS command file used for compiling and
    linking a mathematical VAX C program.  It can be easily altered to
    allow for linking to "naautil.c" object code, speeding up the
    compile time.3.7File Structure Chart

The chart below describes how the files are organized on the
distribution diskettes.

                                 / (root)
                                    ≥
      ⁄ƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒ¬ƒƒ¡ƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒø
      ≥        ≥        ≥        ≥        ≥        ≥        ≥          
     *.C     *.DOC     UTIL    LANGS     IN       OUT      EXE         
                        ≥        ≥        ≥        ≥        ≥
                        ≥        ≥        ≥        ≥        ≥ 
                       *.*       ≥       *.IN    *.OUT    *.EXE
                                 ≥                      (OPTIONAL)
                                 ≥                                  
   ⁄ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒ¡ƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒø   
   ≥           ≥           ≥           ≥           ≥           ≥ 
  ADA        BASIC         C          CPP       FORTRAN      PASCAL  
   ≥           ≥           ≥           ≥           ≥           ≥ 
SIMPSON.ADA SIMPSON.BAS SIMPSON.C  SIMPSON.CPP SIMPSON.FOR SIMPSON.PAS
NAAUTIL.ADA SIMPSON.IN  SIMPSON.H  SIMPSON.HPP SIMPSON.IN  NAAUTIL.INC
SIMPSON.IN  SIMPSON.OUT SIMPSON.IN SIMPSON.IN  SIMPSON.OUT NAAMATH.INC
SIMPSON.OUT            SIMPSON.OUT SIMPSON.OUT             SIMPSON.IN
                                                           SIMPSON.OUT


3.8  File Name Translation Table from 3rd to 4th Edition

This translation table correlates the third edition text algorithms
with the fourth edition text algorithms.  The B and C extensions
indicate algorithms that were changed or replaced from the third
edition and retained with the fourth edition algorithms.            
                                                        
Edition ≥ Edition       Edition ≥ Edition       Edition ≥ Edition
  3rd   ≥   4th           3rd   ≥   4th           3rd   ≥   4th
ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒ      ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒ      ƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒ
  2.1   ≥   2.1           5.3   ≥   5.3           8.6   ≥   9.2
  2.2   ≥   2.2           5.4   ≥   5.4           8.7   ≥   9.3
  2.3   ≥   2.3           5.5   ≥   5.5           8.8   ≥   9.4
  2.4   ≥   2.4           5.6   ≥   5.6           8.9   ≥   9.5
  2.5   ≥   2.5           5.7   ≥   5.7           8.10  ≥   9.6B
  2.6   ≥   2.6           5.8   ≥   5.8           9.1   ≥  10.1
  2.7   ≥   2.7           6.1   ≥   6.1           9.2   ≥  10.2
  3.1   ≥   3.1           6.2   ≥   6.2           9.3   ≥  10.3
  3.2   ≥   3.2           6.3   ≥   6.3          10.1   ≥  11.1
  3.3   ≥   3.3           6.4   ≥   6.4          10.2   ≥  11.2
  3.4   ≥   3.4           6.5   ≥   6.4C         10.3   ≥  11.3
  3.5   ≥   3.5           6.6   ≥   6.6          10.4   ≥  11.4
  4.1   ≥   4.1           6.7   ≥   6.7          10.5   ≥  11.5
  4.2   ≥   4.2           8.1   ≥   7.1          10.6   ≥  11.6
  4.3   ≥   4.3           8.1   ≥   7.1          11.1   ≥  12.1
  4.4   ≥   4.4           8.2   ≥   7.2          11.2   ≥  12.2
  5.1   ≥   5.1           8.3   ≥   7.3          11.3   ≥  12.3
  5.2   ≥   5.2           8.4   ≥   7.4          11.4   ≥  12.4
                          8.5   ≥   9.1          11.5   ≥  12.5
                                                        

3.9  4th Edition Differences                             
                                                        
In the fourth edition's PREFACE, pages vii-viii list the "CHANGES IN
THE FOURTH EDITION".  The specifics of these changes are listed below.

Renamed Algorithms:            4.1, 4.4, 7.1, 7.2, 9.2, 10.1, 11.2
New to 4th Edition:            4.5, 6.5, 9.6
Modified in 4th Edition:           9.5B
Discontinued in 4th Edition:            6.4C, 9.6B


4.   Step-By-Step Examples on Various Computers


This chapter gives four step-by-step examples on several different
computer systems.  The example will use Algorithm 4.1 - Composite
Simpson's Rule for Integration ("041.c") and will compute the integral
of f(x) = 2*cos(x) from 1 to 2 using 20 intervals.

Eight steps are typical every time an algorithm is used.  These steps
are:

    Step #1 - Change to Correct Directory            (operating system)
    Step #2 - Retrieve Algorithm                 (editor)
    Step #3 - Edit Algorithm                     (editor)
    Step #4 - Save Modifications                 (editor)
    Step #5 - Compile Algorithm             (compiler)
    Step #6 - Run Program                   (operating system)
    Step #7 - View Output                   (operating system)
    Step #8 - Print Output                  (operating system)

For two-thirds of the algorithms, Steps 2-4 are unnecessary and Step 5
needs to be done only once.  These files are marked with an asterisk
('*') in the table in Section 3.1.

The examples below will cover these eight steps on four different
computer systems:  MS-DOS PCs, UNIX, Macintoshes, and VAXes.  Before
following any of these examples, first check the need list below and
configure your "naautil.c" file.


4.1  Need List

For this example the files "naautil.c" and "041.c" are needed. 
"Naautil.c" and "041.c" are listed in Appendices A and B to be
conveniently referred to during this example.  A simple text editor
and a C compiler are also required.  The C compiler should be ANSI
compatible if at all possible.  This will save you from possible
incompatibility problems.

It is recommended that you try this example out on your computer
system as you read this section.  Be sure to modify only COPIES of the
original algorithms so the algorithms can be used over and over again
without problems.


4.2  Customizing Naautil.c

The first decisions to be made are what options and flags you would
like to use or set inside the "naautil.c" file.  These flags are
usually set only once.  An explanation of each flag is given below.

ANSI:
If your compiler supports the ANSI C standard, then set ANSI to TRUE. 
Set ANSI to FALSE only if the program will not compile with it set to
TRUE.  This flag mostly effects function prototype styles.

ANSI_FUNCT:
Set this flag to TRUE to use the ANSI style for declaring functions
over the K&R style.  This flag must be set to TRUE if using THINK C
4.0 on a Macintosh.

FILE_SAVE:
If you would like to save the output to a file, then set FILE_SAVE to
TRUE.  The output is still printed to the screen as you run the
program.  Set it to FALSE if you do not want to save the output to a
file.

TITLE_PROMPT:
If you would like to be prompted for an optional title at the start of
each program, then set TITLE_PROMPT to TRUE.  This is useful when the
output is to be handed in as homework, allowing the user's name or the
problem number to be entered.  No title is printed to the output file
if the [ENTER] key is hit by itself.  Set it to FALSE if you do not
want to be bothered with entering a title every time you run an
algorithm.

EQ_EVAL:
Several of the algorithms require a single function to be evaluated. 
Set EQ_EVAL to TRUE if you wish to enter the function during run-time
instead of at compile time.  A couple of simple modifications MUST be
made to your algorithm BEFORE this option will be effective.  See
Chapter 8 - "The Equation Evaluator Routines" for instructions on
using this option.

NAAUTIL_OBJ:
This option is useful for users who wish to speed up the compilation
process.  See Section 6.6 - "Using Naautil.c as Object Code" for more
details.

These examples assume the following default settings:

         FLAG              SETTING
         ANSI              TRUE
         ANSI_FUNCT        FALSE
         FILE_SAVE         TRUE
         TITLE_PROMPT      TRUE
         EQ_EVAL           FALSE   (Is set to TRUE in "041ee.c")
         NAAUTIL_OBJ       FALSE

The ANSI, ANSI_FUNCT and OLD_UNIX_OS flags may need to be changed if
your compiler varies from the ANSI standard.  See Section 6.5 -
"Explanation of the Naautil.c File" for a more thorough explanation of
the "naautil.c" flags.


4.3  Example Using MS-DOS, Microsoft C and the P-Edit Editor

This example uses the following software:

    Operating System:      MS-DOS on an IBM PC
    Compiler:              Microsoft C 5.0
    Editor:                WordPerfect's P-Edit Editor

No special "naautil.c" flags need to be set.

This example assumes the files were installed onto the "C" drive in
the "\NAA42" sub-directory.  The DOS prompt will be represented by
"C:\NAA42> ".


Step #1 - Change to Correct Directory

Assuming the "Numerical Analysis Algorithm in C" files are located in
the "\NAA42" sub-directory of the "C" drive, go there by typing:

    C:\> CD \NAA42                 - changes directories
    C:\NAA42> DIR /P               - shows directory's contents


Step #2 - Retrieve Algorithm

Invoke your text editor and retrieve the algorithm file:

    C:\NAA42> PE 041.C

The file "041.c" is now loaded and is ready for editing.  A text
editor is preferred over a word processor.  If you plan to use a word
processor as your editor, be sure to retrieve and save all files as
text-only files.


Step #3 - Edit Algorithm

You must now modify the function f(x).  F(x) is listed twice - once as
text and once as the actual function call.  All functions are defined
at the top of each program.  To quickly find where modifications are
necessary, search for the '$' character.  This character is used
exclusively for locating lines of code that need updating in all
"Numerical Analysis Algorithms in C" files.

Search for the first '$':

    [F2] $ [F2]                - search

The first '$' should be found at line 22 of "041.c."

Change line 22 from:       char *eq_text_f = "f(x) = sin(x)";
to:                        char *eq_text_f = "f(x) = 2*cos(x)";

This string of text will be printed as output exactly as it appears
inside the quotations when the program is run.

Now search for the second '$':

    [F2] $ [F2]                - search

The second '$' should find the function itself on line 31 of "041.c."

Change line 31 from:       return (sin(x));
to:                        return (2.0 * cos(x));


Step #4 - Save Modifications

Now save the file "041.c" with the above changes and exit the editor:

    [F7] Y [ENTER] Y Y         - save and exit


Step #5 - Compile Algorithm

Now compile and link "041.c" into the executable file "041.exe."  At
the prompt type:

    C:\NAA42> CL 041.C

The batch file "cc.bat" can also be used in place of the "CL" command. 
See Sub-Section 7.3.1 on using "cc.bat."  If the program requires a
larger stack than the default size, using "CL 041.C /link /ST:4096"
will increase the stack from 2K bytes to 4K bytes in Microsoft C 5.0.


Step #6 - Run Program

To run "041.exe", at the DOS prompt type:

    C:\NAA42> 041

The ".exe" extension can be left off.  Answer the prompts with the
predetermined inputs.  The screen should look something like this:

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ ---------------------------------------------------------- ∫
    ∫          "Numerical Analysis Algorithms in C" v4.2         ∫
    ∫ ---------------------------------------------------------- ∫
    ∫                                                            ∫
    ∫ Enter an optional title [ie - Set 2.1,  Problem 2 a) ].    ∫
    ∫ ----> User's Manual Example                                ∫
    ∫                                                            ∫
    ∫ Composite Simpson's Rule - Algorithm 4.1                   ∫
    ∫                                                            ∫
    ∫ f(x) = 2*cos(x)                                            ∫
    ∫                                                            ∫
    ∫ Enter endpoint a: 1                                        ∫
    ∫ Enter endpoint b: 2                                        ∫
    ∫ Enter number of intervals on [a,b], n: 20                  ∫
    ∫ Interval number h = 0.05                                   ∫
    ∫                                                            ∫
    ∫      Ù2                                                    ∫
    ∫ XI = ≥  f(x) dx = 0.13565288875                            ∫
    ∫      ı1                                                    ∫
    ∫                                                            ∫
    ∫ Required 21 functional evaluations.                        ∫
    ∫                                                            ∫
    ∫ Output saved into file "041.out".                          ∫
    »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº
 
As indicated by the output, a file named "041.out" is created which
contains the output results in a ready-to-print format.


Step #7 - View Output

To view the contents of the output file "041.out", use either the DOS
"type" command, the "Numerical Analysis Algorithms in C" utility
"list.com", or your text editor.  See Section 7.2 for instructions on
the usage of the "list.com" utility.

    C:\NAA42> TYPE 041.OUT                  - Using DOS's "type"
or
    C:\NAA42> UTIL\LIST 041.OUT             - Using "list.com"

If the file's contents are accurate, then you are ready to print out a
copy to be turned in as homework.


Step #8 - Print Output

To print out the output file from DOS, type:

    C:\NAA42> PRINT 041.OUT

This step can also be done from within most text editors.  WARNING: Be
careful not to print the executable file "041.exe".  It will waste
reams of paper.


4.4  Example Using UNIX, cc and the vi Editor

This example uses the following software:

    Operating System:      UNIX
    Compiler:              cc
    Editor:                vi

You may need to set the OLD_UNIX_OS flag to TRUE if your C compiler
requires the include file <varargs.h> instead of <stdarg.h> for
variable length argument lists.  See your system's "/usr/include" sub-
directory to determine which include file will be used.

The percent ('%') character will be used to represent the UNIX shell
prompt.


Step #1 - Change to Correct Directory

Assuming the "Numerical Analysis Algorithm in C" files are located in
the "naa42" sub-directory, go there by typing:

    % cd naa42                     - changes directories
    % pwd                          - shows current directory
    % ls -alF                      - shows directory's contents


Step #2 - Retrieve Algorithm

Invoke the vi editor and retrieve the algorithm file:

    % vi 041.c

The file "041.c" is now loaded and is ready for editing.


Step #3 - Edit Algorithm

You must now modify the function f(x).  F(x) is listed twice - once as
text and once as the actual function call.  All functions are defined
at the top of each program.  To quickly find where modifications are
necessary, search for the '$' character.  This character is used
exclusively for locating lines of code that need updating in all
"Numerical Analysis Algorithms in C" files.

Search for the first '$':

    /$                     - search

The first '$' should be found at line 22 of "041.c."

Change line 22 from:       char *eq_text_f = "f(x) = sin(x)";
to:                        char *eq_text_f = "f(x) = 2*cos(x)";

This string of text will be printed as output exactly as it appears
inside the quotations when the program is run.

Now search for the second '$':

    n                      - search (next occurrence)

The second '$' should find the function itself on line 31 of "041.c."

Change line 31 from:       return (sin(x));
to:                        return (2.0 * cos(x));

Here are a few vi editing commands you should know for future
reference:

    i        Enters insert mode  (Exit this mode using [ESC])
    R        Enters typeover mode  (Exit this mode using [ESC])
    r        Replace character
    w        Moves forward one word
    b        Moves backward one word
    x        Deletes a character
    dw       Deletes a word
    dd       Deletes a line
    cw       Changes a word  (follow text by an [ESC] key)
    :#       Go to line number #
    :w       Saves (writes) editor contents to a file
    :q       Quits (exits) the editor
    ZZ       Exits the editor saving all changes  (Same as ":wq")
    [ESC]    Exits insert, typeover, and other editing modes
    /string  Searches forward for string
    ?string  Searches backwards for string
    n        Continue search for string
    Arrow keys, ^g, ^h, ^j, ^k, or [SPACE] move the cursor


Step #4 - Save Modifications

Now save the file "041.c" with the above changes and exit the editor:

    :wq                    - write and quit
or
    ZZ                     - save and exit (faster to type than ":wq")


Step #5 - Compile Algorithm

Now compile and link "041.c" into the executable file "041".  At the
shell prompt type:

    % cc -o 041 041.c -lm

"Cc" invokes the C compiler, "-o 041" (NOT -0) names the executable
program, "041.c" is the source code file name, and "-lm" links with
the math library.  Without the "-o 041" the program would be given the
default name of "a.out".  Without the "-lm" the program would give
incorrect floating-point results.

The script file "ccc" can also be used in place of the "cc" command. 
See Sub-Section 7.3.2 on using "ccc".  It will do the compiling,
running, and will list the output for you.


Step #6 - Run Program

To run "041", at the shell prompt type:

    % 041

Answer the prompts with the predetermined inputs.  The screen should
look something like this:

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ ---------------------------------------------------------- ∫
    ∫          "Numerical Analysis Algorithms in C" v4.2         ∫
    ∫ ---------------------------------------------------------- ∫
    ∫                                                            ∫
    ∫ Enter an optional title [ie - Set 2.1,  Problem 2 a) ].    ∫
    ∫ ----> User's Manual Example                                ∫
    ∫                                                            ∫
    ∫ Composite Simpson's Rule - Algorithm 4.1                   ∫
    ∫                                                            ∫
    ∫ f(x) = 2*cos(x)                                            ∫
    ∫                                                            ∫
    ∫ Enter endpoint a: 1                                        ∫
    ∫ Enter endpoint b: 2                                        ∫
    ∫ Enter number of intervals on [a,b], n: 20                  ∫
    ∫ Interval number h = 0.05                                   ∫
    ∫                                                            ∫
    ∫      [2                                                    ∫
    ∫ XI = |  f(x) dx = 0.13565288875                            ∫
    ∫      ]1                                                    ∫
    ∫                                                            ∫
    ∫ Required 21 functional evaluations.                        ∫
    ∫                                                            ∫
    ∫ Output saved into file "041.out".                          ∫
    »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

As indicated by the output, a file named "041.out" is created which
contains the output results in a ready-to-print format.


Step #7 - View Output

To view the contents of the output file "041.out", use the UNIX "more"
command.

    % more 041.out

If the file's contents are accurate, then you are ready to print out a
copy to be turned in as homework.


Step #8 - Print Output

To print out the output file from the UNIX shell prompt, type:

    % lp 041.out

"Lp" prints the file "041.out" to the line printer.  WARNING: Never
try to print the executable file "041*" (denoted with an '*' when
listed with "% ls -F").  It will waste reams of paper.


4.5  Example Using a Macintosh and THINK C

This example uses the following software:

    Operating System:      Finder or MultiFinder on a Macintosh
    Compiler:              THINK C 4.0 by Symantec
    Editor:                THINK C editor

You will need to set the ANSI_FUNCT flag in "naautil.c" to TRUE to
compile and use functions using variable length argument lists, such
as "printf2(...)" and "eval_eq()".  It simply enforces the newer ANSI
style function declarations over the older K&R style (see Section 9.1
for an example).

The following example was derived from Chapter 3 - "Tutorial: Hello
World" in the THINK C User's Manual.  It replaces the "Hello Folder"
with "041 Folder.„", "hello.c" with "041.c", and uses the ANSI
library.


Step #1 - Create a Project

The first thing you need to do is create a folder called
"041 Folder.„" in the "Development" folder.  Do this before you start
THINK C.  The "041 Folder.„" folder should contain your source files
("041.c"), "naautil.c" and other supporting ".c" files such as
"eqeval.c".  It is good programming practice, though not necessary, to
name your project folders with a ".„" extension.  (To make a „, type
Option p.)

When you've created "041 Folder.„", open the THINK C Folder (the one
that contains the THINK C application) and double click on the THINK C
icon.

You'll see a dialogue box that asks you to open a project.  Since you
are creating a new project, click on the New button.  You'll see
another dialogue box, one that lets you create projects.

Move back to the "041 Folder.„" folder you just created.  It is very
important that you move to this folder.  Name the project
"041 project", and click on the Create button.  THINK C creates a new
project document on disk and displays a project window.


Step #2 - Retrieve Algorithm

To open the algorithm text file, choose the Open... command in the
File menu.  Select the file "041.c" from the menu.


Step #3 - Edit Algorithm

You must now modify the function f(x).  F(x) is listed twice - once as
text and once as the actual function call.  All functions are defined
at the top of each program.  To quickly find where modifications are
necessary, search for the '$' character.  This character is used
exclusively for locating lines of code that need updating in all
"Numerical Analysis Algorithms in C" files.

To search for the first '$' character, choose the Find... command in
the Search menu.  Type a '$' character in the Search for: field and
click the Find button.  It should be found at line 22 of "041.c."

Change line 22 from:       char *eq_text_f = "f(x) = sin(x)";
to:                        char *eq_text_f = "f(x) = 2*cos(x)";

This string of text will be printed as output exactly as it appears
inside the quotations when the program is run.

Now search for the second '$' by choosing the Find Again command in
the Search menu.  The second '$' should find the function itself on
line 31 of "041.c."

Change line 31 from:       return (sin(x));
to:                        return (2.0 * cos(x));

You may want to read Chapter 8 - "The Editor" in your THINK C User's
Manual for more information about the THINK C text editor.


Step #4 - Save Modifications

When you have finished modifying the program, select Save As... from
the File menu to save it.  You will get a dialogue box in which you
should enter the name of the file "041.c", and click on the Save
button.  THINK C will only compile files that end with ".c" or ".C".


Step #5 - Compile Algorithm

Now compile "041.c" into the executable named "041".  To do this,
select Compile from the Source menu.  THINK C displays a dialogue box
that shows how many lines have been compiled.  See your THINK C User's
Manual if you can not resolve any compilation errors.

Next, you need to add the "ANSI" library to your project.  This
library contains all the standard C library routines such as printf(). 
To add the "ANSI" library, choose Add... from the Source menu.

When you get the standard file dialogue box, open the folder called "C
Libraries."  This folder contains all the libraries for ANSI
compatibility, including the "ANSI" library.  Select "ANSI", and click
on the Add button.  WARNING - Do not select "ANSI-small" or "ANSI-A4"
since they do not support floating-point operations.  If you have a
math coprocessor (MC68881), substitute "ANSI" with "ANSI-881".  This
will measurably speed up each algorithm's execution time.

THINK C adds the name "ANSI" to the project window and then puts up
the standard file dialogue box again.  The second time around just
click on the Cancel box.  THINK C will load the library automatically
when you run the project.

IMPORTANT:  You may need to place "ANSI" into its own segment by
dragging "ANSI" below the dotted line and releasing it.  A line
indicates that the code is separated into different segments.  This
may be necessary due to an object code size limitation of 32K bytes
per segment.


Step #6 - Run Program

Everything is all set to run the project.  The source file is in the
project window along with the libraries you will be using.  Now select
Run from the Project menu.

THINK C notices that the library needs to be loaded, so it puts up a
dialogue box asking you if you want to bring the project up to date. 
Click on the Yes button.  THINK C goes to disk to load the code for
the "ANSI" library.  The executable "041" is now being created.

Since all "Numerical Analysis Algorithms in C" programs call the
printf() function, all output will go to a window called "console". 
The console window emulates a generic terminal screen.

The program will now prompt you for inputs.  Answer the prompts with
the predetermined inputs.  The console screen should look something
like this:

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ console ˛∫
    ÃÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕπ
    ∫ ---------------------------------------------------------- ∫
    ∫          "Numerical Analysis Algorithms in C" v4.2         ∫
    ∫ ---------------------------------------------------------- ∫
    ∫                                                            ∫
    ∫ Enter an optional title [ie - Set 2.1,  Problem 2 a) ].    ∫
    ∫ ----> User's Manual Example                                ∫
    ∫                                                            ∫
    ∫ Composite Simpson's Rule - Algorithm 4.1                   ∫
    ∫                                                            ∫
    ∫ f(x) = 2*cos(x)                                            ∫
    ∫                                                            ∫
    ∫ Enter endpoint a: 1                                        ∫
    ∫ Enter endpoint b: 2                                        ∫
    ∫ Enter number of intervals on [a,b], n: 20                  ∫
    ∫ Interval number h = 0.05                                   ∫
    ∫                                                            ∫
    ∫      [2                                                    ∫
    ∫ XI = |  f(x) dx = 0.13565288875                            ∫
    ∫      ]1                                                    ∫
    ∫                                                            ∫
    ∫ Required 21 functional evaluations.                        ∫
    ∫                                                            ∫
    ∫ Output saved into file "041.out".                          ∫
    »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

To exit the program, press the Return key or choose Quit from the File
menu.

As indicated by the output, a text file named "041.out" is created
which contains the output results in a ready-to-print format.


Step #7 - View Output

To view the contents of the output file, use the Open... command in
the File menu and select "041.out."

If the file's contents are accurate, then you are ready to print out a
copy to be turned in as homework.


Step #8 - Print Output

To print out the output file, use the Print... command in the File
menu.  Make sure the output file is in the frontmost edit window. 
You'll see the standard print dialogue for either the ImageWriter or
LaserWriter.

To end this example session, select Close All in the Windows menu to
close all open files.  If a file has not been saved, the editor will
ask you if you want it saved.


Using SANE

As you use these algorithms, you may find it beneficial to use certain
utility functions from the Standard Apple Numerics Environment (SANE). 
The SANE library uses 80-bit values and is not intended for projects
that have the MC68881 Code Generation option checked.

The eight functions below are common to both the SANE and ANSI
libraries:

         atan()            exp()            log()             sqrt()
         cos()             fabs()           sin()             tan()

To use SANE versions, #include the file "SANE.h" before the file
"math.h" inside "naautil.c."  Similarly, to use the ANSI versions,
#include the file "math.h" before the file "SANE.h" in "naautil.c." 
For more information on SANE, read "Apple Numerics Manual, Second
Edition" (Addison-Wesley).


4.6  Example Using VAX/VMS, CC and the EDIT/EDT Editor

This example uses the following software:

    Operating System:      VAX/VMS (really DCL)
    Compiler:              VAX C v3.2 from DEC (CC)
    Editor:                EDIT/EDT or EVE

The dollar ('$') character will be used to represent the VMS command
prompt.


Step #1 - Change to Correct Directory

Assuming the "Numerical Analysis Algorithm in C" files are located in
the "NAA42" sub-directory, go there by typing:

    $ SET DEFAULT [.NAA42]         - changes directories
    $ SHOW DEFAULT                 - shows current directory
    $ DIR/SIZE/DATE                - shows directory's contents


Step #2 - Retrieve Algorithm

Invoke the EDIT/EDT editor and retrieve the algorithm file:

    $ EDIT/EDT 041.C

The file "041.c" is now loaded and is ready for editing.  The first
line of the file is printed to the screen.  An asterisk will follow
which indicates that you are in EDT line editing mode.  It should look
similar this:

    $ EDIT/EDT 041.C
        1       /*****************************************************
****************
    *


Step #3 - Edit Algorithm

Now type "C" or "SET MODE CHANGE" followed by [ENTER] to leave line
editing mode and enter full screen mode where you can use the EDT
function keypad.

    * C [ENTER]

You must now modify the function f(x).  F(x) is listed twice - once as
text and once as the actual function call.  All functions are defined
at the top of each program.  To quickly find where modifications are
necessary, search for the '$' character.  This character is used
exclusively for locating lines of code that need updating in all
"Numerical Analysis Algorithms in C" files.

Search for the first '$' by entering:

    [4] [PF1] [PF3] $

The first '$' should be found on line 22 of "041.c."

Change line 22 from:       char *eq_text_f = "f(x) = sin(x)";
to:                        char *eq_text_f = "f(x) = 2*cos(x)";

This string of text will be printed as output exactly as it appears
inside the quotations when the program is run.

Now search for the second '$' by entering:

    [4] [PF1] [PF3] $

The second '$' should find the function itself on line 31 of "041.c."

Change line 31 from:       return (sin(x));
to:                        return (2.0 * cos(x));

Here are a few EDIT/EDT editing commands you should know:  (^ =
[CONTROL])

    [PF2]         Help
    [PF1][0]          Opens blank line after current line
    [,]           Replace character
    [4][1]        Moves forward one word
    [5][1]        Moves backward one word
    [.]           Deletes a character
    [-]           Deletes a word  (Must be followed by the [ESC] key)
    [PF4]         Deletes a line
    [-]           Changes a word  (Must be followed by the [ESC] key)
    [PF1][7]T#    Moves to line number #
    ^Z EXIT       Quits the editor and saves any changes
    ^Z QUIT       Quits the editor without saving changes
    [ESC]         Terminate input mode
    ^Z            Exits full-screen mode and returns to line mode with *
    [4][PF1][PF3]string        Searches forward for string
    [5][PF1][PF3]string        Searches backwards for string
    [PF1][7] EXIT [ENTER]      Exits editor saving any changes
    Arrow keys, ^g, ^h, ^j, ^k, or [SPACE] move the cursor


Step #4 - Save Modifications

Now save the file "041.c" with the above changes and exit the editor:

    ^Z                - returns to line editing mode and the * prompt
    * EXIT            - save and exit


Step #5 - Compile Algorithm

The VAX C compiler needs to know which libraries to link to.  Two
libraries will be used which will allow floating-point operations. 
Define them once as follows:

    $ DEFINE LNK$LIBRARY    SYS$LIBRARY:VAXCRTLG
    $ DEFINE LNK$LIBRARY_1  SYS$LIBRARY:VAXCRTL

See "HELP CC Link_libraries" to make sure the defines above are
correct for your VAX as well (/G_FLOAT without Curses).

Now compile and link "041.c" into the executable file "041.exe".  At
the VAX prompt type:

    $ CC /G_FLOAT 041.C
    $ LINK 041, LNK$LIBRARY/LIB, LNK$LIBRARY_1/LIB

"Cc" compiles "041.c" into "041.obj" object code.  "Link" names the
executable "041.exe" after linking it to the appropriate libraries. 
For machine specific information on the "link" command, use the on-
line help by typing "HELP CC LINK" and "HELP LINK."

The command file "vaxcc.com" can also be used in place of the "cc" and
"link" commands.  See Sub-Section 7.3.3 on using "vaxcc.com".  It will
do the compiling and linking in one simple step, assuming the link
libraries are correct.  Using it is as easy as typing:

    $ @VAXCC.COM 041           - replaces Step #5 entirely


Step #6 - Run Program

To run "041.exe", at the VAX prompt type:

    $ RUN 041

Answer the prompts with the predetermined inputs.  The screen should
look something like this:

    …ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª
    ∫ ---------------------------------------------------------- ∫
    ∫          "Numerical Analysis Algorithms in C" v4.2         ∫
    ∫ ---------------------------------------------------------- ∫
    ∫                                                            ∫
    ∫ Enter an optional title [ie - Set 2.1,  Problem 2 a) ].    ∫
    ∫ ----> User's Manual Example                                ∫
    ∫ Composite Simpson's Rule - Algorithm 4.1                   ∫
    ∫                                                            ∫
    ∫ f(x) = 2*cos(x)                                            ∫
    ∫                                                            ∫
    ∫ Enter endpoint a: 1                                        ∫
    ∫ Enter endpoint b: 2                                        ∫
    ∫ Enter number of intervals on [a,b], n: 20                  ∫
    ∫ Interval number h = 5.000000e-02                           ∫
    ∫                                                            ∫
    ∫      [2                                                    ∫
    ∫ XI = |  f(x) dx = 0.13565288875                            ∫
    ∫      ]1                                                    ∫
    ∫                                                            ∫
    ∫ Required 21 functional evaluations.                        ∫
    ∫                                                            ∫
    ∫ Output saved into file "041.out".                          ∫
    »ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕº

As indicated by the output, a file named "041.out" is created which
contains the output results in a ready-to-print format.


Step #7 - View Output

To view the contents of the output file "041.out", use the "TYPE"
command.

    $ TYPE/PAGE 041.OUT

If the file's contents are accurate, then you are ready to print out a
copy to be turned in as homework.


Step #8 - Print Output

To print out the output file from the VMS prompt, type:

    $ PRINT 041.OUT

WARNING: Never try printing the executable file "041.exe."  It will
waste reams of paper.


5.   For Those New to C


This chapter will introduce you to the C programming language and some
of its basic functions and features.  if you are new to C, it will be
to your advantage to take a few minutes to read through this chapter
before you move on.  If you are already familiar with C, you may want
to glance through this chapter to remind you of the math library
functions found in <math.h>.

The C language has been around since 1978.  Its popularity continues
to grow especially among universities and industry.  C is usually
learned as a second language after learning Pascal or FORTRAN.  This
chapter is intended to give unexperienced programmers a push in the
right direction.

The easiest way to learn C is by example.  This chapter also lists the
preferred reference books, the mathematical operators and functions,
and compares C with other popular programming languages -- along with
examples.

If you do not own a C compiler and you have access to an IBM PC
computer, and you do not want to pay much to get one (student mode),
there are some low cost compilers on the market that you may wish to
investigate.  One such compiler is "Power C".  This ANSI compatible C
compiler lists for only $19.95.  To order, call 1-800-333-0330, or
write to: MIX Software, 1132 Commerce Dr., Richardson, TX 75081, (214)
783-6001.  Turbo C and Microsoft C seem to be among the most popular
DOS C compilers on the market.

The definitive book on the C language is "The C Programming Language",
Second Edition, by Brian W. Kernighan and Dennis M. Ritchie (Cost:
$28.00).  If you are using an older C compiler (pre-1987), you may
find the first edition more useful.  This 272 page book was written by
the creators of C at AT&T Bell Laboratories.  All other books on C are
derivatives of this book.

The syntax of older C compilers follows the first edition of "The C
Programming Language."  This pre-standard is often referred to as K&R
style, named after its authors, Kernighan and Ritchie.  The second
edition was revised to conform to the ANSI standard.


5.1  Mathematical Operators

The following operators are used to write mathematical equations in C. 
These operators are built-in to the C language.  For more detailed
descriptions, see your C compiler's documentation.

Operator          Description
*            Multiplication.  Not to be confused with pointers.
             Example:  a = b * c;

/            Division.  Chops to nearest integer if using integer
             types.  For instance,  11 / 4 = 2 since the remainder of 3
             is discarded.  11.0 / 4.0 = 2.75.
             Example:  a = b / c;

%            Remainder.  Also called the modulus operator.  Use fmod()
             and/or modf() for floats and doubles.  For instance, 11 %
             4 = 3 since the quotient of 2 is discarded.
             Example:  a = b % c;

+            Addition.
             Example:  a = b + c;

-            Subtraction and arithmetic negation.
             Example:  a = b - c;  and  a = -b;

++           Increment.  For instance, i++; is shorthand for i = i + 1;
             Example:  i++;  (post-increment)  and  ++i; 
             (pre-increment)

--           Decrement.  For instance, i--; is shorthand for i = i - 1;
             Example:  i--;  (post-decrement)  and  --i; 
             (pre-decrement)

*=           Multiplication assignment.  For instance, x *= 3.14 + y;
             is shorthand for x = x * (3.14 + y);

/=           Division assignment.  For instance, x /= 3.14 + y; is
             shorthand for x = x / (3.14 + y);

%=           Remainder assignment.  Integers only.  For instance, a %=
             314 + b; is shorthand for a = a % (314 + b);

+=           Addition assignment.  For instance, x += 3.14 + y; is
             shorthand for x = x + (3.14 + y);

-=           Subtraction assignment.  For instance, x -= 3.14 + y; is
             shorthand for x = x - (3.14 + y);


5.2  Mathematical Functions

The following functions are useful when writing mathematical equations
in C.  These functions are not part of the C language proper, but are
part of the standard library, an environment that supports standard C. 
For more detailed descriptions of these libraries, see your C
compiler's documentation.  Another good place to browse is inside the
include files <math.h> and <stdlib.h>.  These two include files
provide the function declarations for most of the below functions.

Listed below are the variable types used in the examples.

         Type              Variables
         float             w;
         double            x, y, exp;
         int               *expptr, *intptr, n;
         long int          p, q;
         char              *string;
         div_t             num, denom;
         struct complex    z;

struct complex { double r,i; } z;  /* Real and imaginary components */

#include <math.h>          - must be included to use these functions!
#include <stdlib.h>        - must be included to use these functions!


Function          Description
abs(n)       Returns the absolute value of its integer argument.

acos(x)      Returns the arccosine of x in the range 0 to „.  The value
             of x must be between -1 and 1.

asin(x)      Returns the arcsine of x in the range -„/2 to „/2.  The
             value of x must be between -1 and 1.

atan(x)      Returns the arctangent of x in the range -„/2 to „/2.

atan2(y,x)   Returns the arctangent of y/x in the range -„ to „. 
             Unlike atan(), atan2() uses the signs of both x and y to
             determine the true quadrant of the return value.

atof(string)      Converts a character string into a double-precision
                  floating-point value.

atoi(string)      Converts a character string into an integer value.

cabs(z)      Returns the absolute value of a complex number, which must
             be a structure of type complex (shown above).   Equivalent
             to sqrt(z.x*z.x + z.y*z.y).  NOT IN ANSI STANDARD.

ceil(x)      Returns a double-precision floating-point value
             representing the smallest integer not less than x.  Also
             called the postage stamp function.
             Example: ceil(1.05) = 2.0,  ceil(-1.05) = -1.0

cos(x)       Returns the cosine of x, where x is in radians.

cosh(x)      Returns the hyperbolic cosine of x.

div(num,denom)    Computes the quotient and remainder of num/denom.  The
                  results are stored in the int members quot and rem of
                  a structure of type div_t.

exp(x)       Returns the exponential function of its floating-point
             argument x.  Also called Euler's or the natural number, e
             ˜ 2.71828182845.

fabs(x)      Returns the absolute value of its floating-point argument
             x.

floor(x)     Returns a double-precision floating-point value
             representing the largest integer not greater than x.  Also
             called the greatest integer function, [ ].
             Example: floor(1.05) = 1.0,  floor(-1.05) = -2.0

fmod(x,y)    Returns the floating-point remainder f of x/y such that x
             = i*y + f, where i is an integer.  f has the same sign as
             x, and the absolute value of f is less than the absolute
             value of y.  If y is zero, the result is implementation
             defined.

frexp(x,expptr)   Breaks down the floating-point value, x, into a
                  mantissa, p, and an exponent, q, such that the
                  absolute value of p is Ú 0.5 and < 1.0, and x = p*2^q. 
                  The integer exponent is stored in the location pointed
                  to by expptr.  If x is zero, both parts of the result
                  are zero.

hypot(x,y)   Returns the length of the hypotenuse of a right triangle,
             given the length of the two sides x and y.  Equivalent to: 
             sqrt(x*x + y*y).  NOT IN ANSI STANDARD.

ldexp(x,exp)      Returns x * 2^exp.

log(x)       Returns the natural logarithm of x, x > 0.

log10(x)     Returns the base-10 logarithm of x, x > 0.

modf(x,intptr)    Breaks down the floating-point value x into fractional
                  and integer parts.  The signed fractional portion of x
                  is returned.  The integer portion is stored as a
                  floating-point value at intptr.

pow(x,y)     Returns x raised to the yth power (x^y).  A domain error
             occurs if x = 0 and y Û 0, or if x Û 0 and y is not an
             integer.

rand()       Returns a pseudo-random integer in the range 0 to
             RAND_MAX, which is at least 32,767.

sin(x)       Returns the sine of x, where x is in radians.

sinh(x)      Returns the hyperbolic sine of x.

sqrt(x)      Returns the square root of x, x Ú 0.

srand(seed)  Uses seed as the seed for a new sequence of pseudo-random
             numbers.  The initial seed is 1.

tan(x)       Returns the tangent of x, where x is in radians.

tanh(x)      Returns the hyperbolic tangent of x.


AVAILABLE AS EXTENSIONS ON SOME C COMPILERS (ie - MIPS for an
R3000A/R3010):

fsin(w)      Sine for floats.  Sin(x) is for doubles.

fcos(w)      Cosine for floats.  Cos(x) is for doubles.

ftan(w)      Tangent for floats.  Tan(x) is for doubles.

fasin(w)     Arcsine for floats.  Asin(x) is for doubles.

facos(w)     Arccosine for floats.  Acos(x) is for doubles.

fatan(w)     Arctangent for floats.  Atan(x) is for doubles.

fsinh(w)     Hyperbolic sine for floats.  Sinh(x) is for doubles.

fcosh(w)     Hyperbolic cosine for floats.  Cosh(x) is for doubles.

ftanh(w)     Hyperbolic tangent for floats.  Tanh(x) is for doubles.5.3General Language Hints


Ternary Statements:

C has a couple of constructs that may be foreign to users used to
FORTRAN 77 or other high level languages.  One of these is the ternary
statement:

         a = b ? c : d;

which is equivalent to:

         if (b == TRUE)
             a = c;
         else
             a = d;

A couple of examples might include:

         max = (a > b) ? (a) : (b);
or
         printf("%d iteration%s", iter, (iter > 1) ? "s" : "");
         /* Prints: "1 iteration" and "2 iterations" */


Defining TRUE and FALSE:

Remember, in C "0" is FALSE while anything other than "0" is defined
as TRUE.  For example:

         -2  = TRUE
         -1  = TRUE
          0  = FALSE
          1  = TRUE   (default)
          2  = TRUE

Usually, TRUE and FALSE are defined as "#define FALSE 0" and "#define
TRUE !FALSE" or "#define TRUE 1".


Common Equivalents:

         SHORT HAND        LONG HAND
         if (expr) ...     if (expr == TRUE) ...
         if (!expr) ...    if (expr == FALSE) ...
         i++               i = i + 1
         i--               i = i - 1
         i += 2            i = i + 2
         i -= 2            i = i - 25.4Language Transition Kit

Many numerical analysis students may already be familiar with another
programming language other than C.  This section is intended to help
those who have learned other languages other than C to transfer their
knowledge easily into C.  To accomplish this goal, two large
appendices have been compiled.

Appendix C contains a set of charts comparing C statements with those
of other popular languages.  The tables provided should help in
understanding and modifying the equations and code as needed to
perform numerical analysis.  These tables show a simple comparison of
programming statements most likely to be used in numerical analysis
programs.

Appendix D contains a set of working examples in six different
languages.  These source code examples show how programs look in each
of these languages.  These programs do numerical integration using
Algorithm 4.1 - Composite Simpson's Rule.  Each program was compiled
and run to ensure they were logically and syntactically correct.  The
input, output, and include files are also listed for completeness. 
These files are included in the LANGS sub-directory on the
distribution diskettes.

The list below shows the language, compiler and standard used to
create the comparison charts and example programs.

    LANGUAGE      COMPILER                  STANDARD
1.  Ada           Meridian Ada 4.1               ANSI/MIL-STD-1815A
2.  BASIC         Microsoft GW-BASIC 3.20
3.  C             Microsoft C 5.0                ANSI C
4.  C++           Borland Turbo C++ 2.0          AT&T 2.0 C++
5.  FORTRAN 77    Microsoft FORTRAN 77 3.3       ANSI FORTRAN 77
6.  Pascal        Borland Turbo PASCAL 3.01A

This language transition kit, comprised of Appendices C and D, account
for one-third of this User's Manual.  They are not really a necessary
part of the "Numerical Analysis Algorithms in C' package, but they
tremendously aid those who are new or "rusty" on their computer
programming skills.


6.   Helps and Hints


This chapter contains many of the fine details that can make your use
of this software package a pleasant experience.  Read each section as
soon as possible to avoid wasting unnecessary time with tasks or
problem solving.  The sections below are designed to save you time,
improve your confidence in the algorithms, bring your attention to
compiler and text errors, and help you customize the programs to best
suit your needs.


6.1  Generally Nice To Know

The following sub-sections will give you a better understanding of how
to manipulate and customize these algorithms.  They may even save you
the trouble of learning any peculiarities of "Numerical Analysis
Algorithms in C" the hard way.


6.1.1Professor's Favorites, Must Have, Algorithms

Six algorithms have been included as requested by several Brigham
Young University mathematics professors.  These programs are not
included in the text, but serve to enhance it.  In reality, these are
the programs that had to be included in order to persuade Brigham
Young University to convert from FORTRAN to C.  Each of these programs
are named with an "A.c" suffix.  These algorithms are:

    028A.c   - Complex Polynomial Solver (CPOLY)
    101A.c   - Steffenson's Method for Systems
    126A.c   - Parabolic Equations With Newton Iteration in 1-D
    127A.c   - Parabolic Equations With Newton Iteration in 2-D
    128A.c   - Elliptic Equations With Newton Iteration in 2-D
    129A.c   - Biharmonic Equation Using Gauss-Jordan Method


6.1.2Homework Helper Algorithms

Each algorithm not specifically given in the text has a B, C, or D
placed before the ".c" extension in its file name.  Roughly a third of
all the programs included are modifications to the given text
algorithms.  Many of them are requested as homework exercises.  These
modifications range from implementing SIG-digit rounding, or adding
Richardson's extrapolation, to solving for AX=B after performing
matrix factorization.

Each program has a comment block at the top of the file.   This
comment block also indicates which page of the text and which problem
numbers to expect to use these "Homework Helper" algorithms.  This was
included to show where these modifications fit into the text.


6.1.3Optional Title

Each program begins by prompting for a one-line title.  This title is
printed to the output file for your convenience.  If you do not want a
title then just enter a [RETURN] or [ENTER] and no title will be used. 
To turn off the prompt for an optional title, simply change the
TITLE_PROMPT flag to FALSE in the file "naautil.c."


6.1.4Optional File Saving

Each program has a default output file name associated with it.  This
file has the same name as the program being run, but with a ".out"
extension.  The default setting in "naautil.c" is to create an output
file as a program is run.  To run a program without saving the output
to the default output file, just change the FILE_SAVE flag to FALSE in
the file "naautil.c."

Errors may result if your disk is too full or the disk is write-
protected while the FILE_SAVE flag is set to TRUE.


6.1.5Finding Functions

Many of the algorithms require a function to be evaluated.  These
algorithms can be found in chapters 2, 4, 5, 8, 11, and 12.  The
functions are printed out to the screen and to the output file.  Each
function needs changing in two places, once in the function itself,
and once in the comments to be printed out.  Both of these are shown
at the top of each program before main().  To aid you in finding these
functions, search for the "$" character.  This is the only use of the
"$" symbol throughout all the programs.


6.1.6Using Default Inputs

Several of the programs ask if another input needs to be evaluated. 
Make use of the default inputs as shown by just pressing the [ENTER]
key.  This will make repetitious loops easier to use. Example: 
"Evaluate another value of X? (Y/N) Y"  means just press [ENTER] for
Yes.

There is no default for entering tolerances (TOL).  When shown one, it
is a suggested tolerance, not a default.  Hitting [ENTER] will cause
the program to keep waiting (blank stares) until a valid floating-
point number is entered.

Entering text where numbers are expected or numbers where text is
expected will cause the programs to "crash" and usually enter an
infinite input loop.  This is characteristic of the scanf() function. 
This unfortunate situation can usually be remedied by typing
"[CONTROL] C".  Many of the algorithms perform user-friendly range
checking, but not data type checking.


6.1.7Changing Arithmetic Precision

There may be a "slight" difference to the solutions that these
algorithms produce as compared to those shown in the text examples. 
This is usually a result of different word sizes used in the
computations (ie - float, double, long double).  This is a computer
and compiler dependant situation and can be expected -- within reason. 
Only deviations in the least significant digits should be noticeable. 
An accumulation of this round-off error may result in the variation of
even more significant digits.  See the header file <float.h> for the
expected number of significant digits when using your C compiler.

Most digital computers use floating-point formats which provide a
close but by no means exact simulation of real number arithmetic. 
Among other things, the associative and distributive laws do not hold
completely (i.e. order of operation may be important, repeated
addition is not necessarily equivalent to multiplication).  Underflow
or cumulative precision loss is often a problem.

Do not assume that floating-point results will be exact.  These
problems are no worse for C than they are for any other computer
language.  Floating-point semantics are usually defined as "however
the processor does them;" otherwise a compiler for a machine without
the "right" model would have to do prohibitively expensive emulations. 
More accurate result can usually be obtained by increasing the
precision from type "float" to type "double", or from type "double" to
type "long double."

When changing a program's precision to or from different floating-
point types, remember to change the following:

                  FLOAT            DOUBLE            LONG DOUBLE
Variables:        float            double            long double

printf():         %f               %lf               %Lf
                  %g or %G         %lg or %lG        %Lg or %LG
                  %e or %E         %le or %lE        %Le or %LE
                  % f, etc.        % lf, etc.        % Lf, etc.
                  %.9f, etc.       %.16lf, etc.      %.25Lf, etc.

naautil.c:        vector();        dvector();
                  matrix();        dmatrix();

naautil2.c:                                          ldvector();
                                                     ldmatrix();

Some C compilers may add an "f" prefix to their math functions to
distinguish them as returning float types instead of the usual double
type.  These may be implemented as compiler extensions (such as the
MIPS C compiler) but are not part of the ANSI C standard.

         Float             Double
         fsin();           sin();
         fcos();           cos();
         ftan();           tan();
         fasin();          asin();
         facos();          acos();
         fatan();          atan();
         fsinh();          sinh();
         fcosh();          cosh();
         ftanh();          tanh();


6.1.8Using Floating-Point Numbers in Functions

When modifying function equations, be sure to type all constants in
floating-point format.  Good C compilers know that if one argument in
an expression is a floating-point value then all integer types will be
promoted (converted) to floating-point values.  There is no guarantee
of getting a correct result especially since many older compilers do
not implement strong prototyping.

A common error is to type:

    return ((3/2)*sin(x));                  /* Bad Example */

instead of:

    return ((3.0/2.0)*sin(x));              /* Good Example */

The first expression returns "1*sin(x)" while the later returns
"1.5*sin(x)".  The first is incorrect since with C integer arithmetic,
3/2 equals 1, being truncated to the nearest integer.  A "lazy man's"
way is to type:

    return ((3./2)*sin(x));                 /* Good Example */


6.1.9The Pow() Function

Remember, pow() requires both arguments to be double-precision
floating-point types (double).  For  instance, to raise 5.8 to the 3rd
power, type "pow(5.8,3.0)" not "pow(5.8,3)".


6.1.10 Implementing SIG-Digit Rounding/Truncation

To modify a program to work with SIG-digit rounding arithmetic, do the
below steps:

NOTE:    To implement SIG-digit truncation or chopping, replace the
         word "round" with the word "trunc".

Example:
         #include "round.c" ---> #include "trunc.c"
         round(num,SIG) -------> trunc(num,SIG)

1.  Add the below #include file:

         #include "round.c" /* Rounds X to SIG significant digits. */

    This file requires <float.h> and <math.h> which are already
    included inside of "naautil.c."

2.  Add to the global variable list, above main() (or locally inside
    of main() if round() is ONLY used inside main()), the following:

         int SIG;

3.  Prompt for the number of significant digits, SIG, using the code:

  do {
    printf("Enter the number of significant digits, SIG (1-%d): ",
      DBL_DIG);
    scanf("%d", &SIG);
    if (SIG < 1 || SIG > DBL_DIG)           /* Range checking */
      printf("Enter 1 to %d only for number of significant digits.\n",
        DBL_DIG);
  } while (SIG < 1 || SIG > DBL_DIG);
  fprintf(file_id, "Computed with %d-digit rounding arithmetic.\n\n",
    SIG);
 
    NOTE:    DBL_DIG is defined in <float.h> and is usually has the
             value of around "10".
 
4.  Now, for EVERY number and after EVERY computation (ie- +,-,*,/,
    pow(), sqrt(), etc.) add a line similar to the following:

         num = round(num, SIG);

    or just "round(num, SIG)" if in the middle of an equation.

5.  (OPTIONAL) Change the output line to show only SIG digits using
    "*" and "SIG", like:

         printf("% *g ", SIG, X[i]);

6.  (OPTIONAL) Change all doubles to floats and all "%lg", "%lf", and
    "%le"'s to "%g", "%f", and "%e" as well as all dmatrix() and
    dvector() to matrix() and vector() as explained in Sub-Section
    6.1.7.

7.  If the Tolerance is prompted for, like below:

         printf("Enter the tolerance, TOL (1.0e-4): ");
         scanf("%lf", &TOL);
         fprintf(file_id, "Tolerance = %lg\n\n", TOL);

    replace it with:

         TOL = 0.5*pow(10.0, -((double) SIG));
         fprintf(file_id, "Tolerance = %lg\n\n", TOL);


6.1.11 Floating-Point Output Alignment

Many of the programs attempt to print out answers in columns, such as
for tables (chapters 2, 3, 5, 7-12) and matrices (chapters 6, 7, 9). 
Assuming the majority of the programs would be used for "normally
small" numbers, printf() was used with "%g" and "%f" format arguments. 
This can causes the output to appear unaligned if large numbers are
printed along side small numbers.  If you would like to have the
output align all the time then use "%e".  This forces ALL numbers to
be of the form:

    -3.14159e-002          [sign] [mantissa] e [[sign] exponent]

Alignment is guaranteed, but the numbers often take up more room than
is necessary and can be less easy to read.


6.2  Converting Programs into Functions

After becoming familiar with several of these algorithms, many users
desire to use them as stand-alone functions to be called from within
other C programs.  Several books may be purchased which provide only
functions, not stand-alone programs, such as the book "Numerical
Recipes."  Extra care has been placed into all of the "Numerical
Analysis Algorithms in C" programs to help make converting them into
functions easier.

Modifying these algorithms to be FORTRAN callable is also possible. 
The details for this procedure are too detailed and compiler dependent
to be listed in this general-purpose User's Manual.

Converting a stand-alone algorithm into a function can be simpler than
you might think.  Most of the process involves deleting the
unnecessary input and output code.  An example using Algorithm 4.1
listed in Appendix A is given for completeness.

To convert a stand-alone program into a function, perform the
following steps:

1.  Rename "main()" to a proper function name, such as "simpson()." 
    Be sure to place the appropriate return type (usually double)
    before the function name.  Example:

    From:    main()
    To:      double simpson()

2.  Separate the variables that follow "main()" into two groups: those
    to be passed as parameters and those that are internal to the
    function.  Refer to the INPUT section in the comments at the top
    of each algorithm to determine the passed parameters.  Place the
    passed parameters into the function parentheses, such as:

         double simpson (a, b, n)           /* K&R Style */
         double a, b;
         int n;
    or
         double simpson (double a, double b, int n)  /* ANSI Style */

    Ensure that the internal variables are placed after the first "{"
    character.

3.  Delete any unnecessary global variables, such as "char
    *outfile ..." and "char *eq_text_f ..."

4.  Replace all function definitions (not calls), such as f(x), with a
    proper prototype, such as:

         double f();               /* K&R Style */
    or
         double f(double x);       /* ANSI Style */

    This instructs your C compiler that the function f receives a
    variable of type double and returns a result of type double. 
    Failure to do this may cause the function f to return erroneous
    integer results.

5.  Remove most all of the code under the INPUTS section.  You may
    want to keep any range checking code, such as:

         if (n <= 0) {
           printf("ERROR - n must be greater than zero.\n);
           exit (-1);              /* Exit to system */
         }

6.  Keep the code under the ALGORITHM section.  This will form the
    "brains" of the new function.

7.  Replace all of the code under the OUTPUTS section with a single
    return() statement.  The only exception would be to leave any
    "free_*()" calls.  The return() call should be the last statement
    of the new function.  The return value should match that in the
    top comments of the program.  For "041.C", use:

         return (XI);

8.  Double-check for and remove any unwanted printf() and scanf()
    routines.  Most mathematical functions do not use them.  Scanf()
    data should be passed to the function, while printf() output
    should be handled by the calling main program.


6.2.1An Example Using Simpson's Rule

Algorithm 4.1 - Composite Simpson's Rule ("041.c") was converted into
a stand-alone function named simpson() as shown below.  This function
can also be found in the UTIL sub-directory in a file named
"041fun.c."

/*********************************************************************
                  Composite Simpson's Rule - Algorithm 4.1
                           As A Stand-Alone Function
**********************************************************************

                                Ùb
To approximate the integral I = ≥  f(x) dx:
                                ıa

INPUT endpoints a, b; even positive integer n; the function f().

OUTPUT approximation XI to I.

NOTE: Listed as Simpson's Composite Rule in 3rd edition of the text.

**********************************************************************
*  Written by:  Harold A. Toomey, CARE-FREE SOFTWARE, 3Q 1991, v4.2  *
*********************************************************************/

#include "naautil.c"       /* Numerical Analysis Algorithms Utilities. */

double f(double x);                /* Function prototype */


double simpson (a, b, n)
double a, b;
int n;
{
  double h, X, XI, XI0, XI1, XI2, f();
  int i;

  if ((n <= 0) || (n % 2 != 0)) {           /* Range checking */
    printf("ERROR - n must be even and greater than zero.\n");
    exit (-1);                     /* Exit to system */
  }

  /*************
   * ALGORITHM *
   *************/

  /* STEP #1 */
  h = (b - a)/n;

  /* STEP #2 */
  XI0 = f(a) + f(b);
  XI1 = 0.0;                       /* Summation of f(x(2i-1)). */
  XI2 = 0.0;                       /* Summation of f(x(2i)).   */

  /* STEP #3 */
  for (i=1;i<n;i++) {

    /* STEP #4 */
    X = a + i*h;

    /* STEP #5 */
    if (i % 2 == 0)
      XI2 += f(X);                 /* For even i. */
    else
      XI1 += f(X);                 /* For odd i.  */
  }

  /* STEP #6 */
  XI = h*(XI0 + 2.0*XI2 + 4.0*XI1) / 3.0;

  return (XI);

}                                  /* STOP */

/********************************************************************/
/*  Copyright (C) 1988-1991, Harold A. Toomey, All Rights Reserved. */
/********************************************************************/


6.3  Using Input Files (*.IN)

An input file is provided in the IN sub-directory for each algorithm. 
Each file contains the same name as the algorithm, but with a ".in"
extension instead of ".c".  The contents of each input file match the
examples given in the text following each algorithm.  They were used
to create the accompanying output files for each algorithm in the OUT
sub-directory.

Input files can be used to save time.  They are especially helpful
when working with large arrays where only small changes are made from
run to run.  Input files consist of simple text just as you would
enter it if the program prompted you for it.

Please note that the input files provided with "Numerical Analysis
Algorithms in C" require that the below "naautil.c" flags be set as
follows:

         FLAG              SETTING
         TITLE_PROMPT      TRUE
         EQ_EVAL           FALSE

Input files can be redirected as input as a program is run.  For example, to "feed" Algorithm 4.1 with
data from an input file, type one of the following:

MS-DOS:
     C:\NAA42> 041 < IN\041.IN

UNIX:
     % 041 < in/041.in

VAX/VMS:
     $ DEFINE SYS$INPUT 041.IN     - assumes "041.IN" is in the current directory
     $ RUN 041
     $ DEASSIGN SYS$INPUT

MACINTOSH with THINK C 4.0:

     To use redirection on a Macintosh with the THINK C 4.0 compiler, each algorithm must be
     modified as follows:

     1.    Add these two lines of code just before main():

                  #include <console.h>
                  int ccommand (char ***p);

     2.    Add arguments (parameters) to main() as shown below:

                  main(int argc, char **argv)

     3.    Just after the variable declarations for main() and before calling "NAA_do_first(outfile);",
           add:

                  argc = ccommand(&argv);

     After making these modifications, Algorithm 4.1 should look like this:

         ...
         #include <console.h>
         int ccommand (char ***p);

         main(int argc, char **argv)
         {
           double a, b, h, X, XI, XI0, XI1, XI2, f();
           int i, n;

           argc = ccommand(&argv);

           NAA_do_first(outfile);  /* NAA initialization procedure. */
           ...
         }

     Be sure to link to the "ANSI" library.  It contains the ccommand() console command.

     Now, when the modified algorithm is run, a command-line window will appear.  Ensure that the
     input file is in the same folder as "041.c" and enter: "041 < 041.in".


6.4  Using Output Files (*.OUT)

An output file is provided in the OUT sub-directory for each algorithm.  They contain the same name as
the algorithms, but with a ".out" file extension instead of ".c".  The default name of an algorithm's output
file can be easily changed by modifying "char *outfile = "nnn.out"; " at the top of each individual
algorithm.  The contents of each output file match the examples given in the text following each
algorithm.  They were created by redirecting the input files found in the IN sub-directory.

These output files can be used to verify that each algorithm is performing as expected.  Use them to
compare your output results on your computer system.

Output files differ somewhat from what you see when a program is run.  Output files format the output
into a more condensed and ready-to-print format.  They are created with calls to printf2() and
fprintf(file_id,...) ONLY.  The FILE_SAVE flag in "naautil.c" must be set to TRUE to create output
files.


6.5  Explanation of the Naautil.c File

The "naautil.c" file is the most important file of all the "Numerical Analysis Algorithm in C" files.  It
contains functions and routines that are used in every algorithm.  It also allows these programs to work
on many non-standard C compilers.  The "naautil.c" file should be included in all of the programs using
#include "naautil.c".

If your C compiler is not truly ANSI C compliant, the "naautil.c" file will be the first to correct it or the
first to cause error messages.  The complete source code for "naautil.c" is listed in Appendix B.  This file
also contains several flags or #define statements which you can set to get the most out of these
algorithms.

"Naautil.c" also defines the constant „ (PI) ˜ 3.14159..., although it can often be found in some system
header files.  It is most useful in trigonometric functions.  The constants "TRUE" and "FALSE" are also
defined just in case the system header files fail to define them.


6.5.1#Define Flags

"Naautil.c" has eight flags that can be set.  Most are usually set only once.  An explanation of each flag is
given below.

ANSI:
If your compiler supports the ANSI C standard, then set ANSI to TRUE.  Set ANSI to FALSE only if
the programs will not compile with it set to TRUE.  This flag is used for strong prototyping of functions. 
It is used by all of the supporting ".c" files and in the utilities as well.

ANSI_FUNCT:
This flag should be set to TRUE to use ANSI style functions.  Setting it to FALSE should work on truly
ANSI compliant compilers as well.  See Section 9.1 for an example.  This flag must be set to TRUE for
THINK C 4.0 on a Macintosh.

FILE_SAVE:
If you would like to save the output of the algorithms to a file, then set FILE_SAVE to TRUE.  The
output is still printed to the screen as you run the program.  Set it to FALSE if you do not plan to save
the output to a file.  Used only in the functions printf2(), NAA_do_first(), and NAA_do_last().

TITLE_PROMPT:
If you would like to be prompted for an optional title at the start of each program, then set
TITLE_PROMPT to TRUE.  This is useful when the output is to be handed in as homework, allowing
the user's name or the problem number to be entered.  Hitting the [ENTER] key, instead of text for a
title, causes no title to be printed to the output file.  Set it to FALSE if you do not want to be bothered
with entering a title every time you run an algorithm.  Used only in the function NAA_do_first().

EQ_EVAL:
Several of the algorithms require a single function to be evaluated.  Set EQ_EVAL to TRUE if you wish
to enter the function during run-time instead of at compile time.  A couple of simple modifications were
made to the algorithms to allow this option to work.  See Chapter 8 - "The Equation Evaluator Routines"
for instructions on using this option.

When this flag is set to TRUE, the 1000+ line file "eqeval.c" is included into "naautil.c" and compiled
with the algorithm.  This flag is used in the function NAA_do_first() as well as in "041ee.c" and "ee.c" in
the UTIL sub-directory.

NAAUTIL_OBJ:
This option is useful for frequent users who wish to speed up the compilation process.  It should be set
to TRUE only if "naautil.c" has been pre-compiled into object code.  See Section 6.6 - "Using Naautil.c as
Object Code" for more details.

OLD_UNIX_OS:
This flag is only necessary for older UNIX computers which use <varargs.h> instead of <stdarg.h> as
the header file for variable length argument lists.  Variable length arguments are used only in printf2()
and in "eqeval.c" 's eval_eq() routine.

NO_LONG_DOUBLES:
Set this flag to TRUE if you are not using the "long double" type routines for higher precision, or if your
compiler does not support the "long double" type.  The "long double" type is used in several routines in
"naautil2.c", but is not used in any of the algorithms.  It is provided for the user to obtain more accurate
numeric results wherever float of double types are being used.  This flag should be set to TRUE for
some VAX C compilers.  Setting this flag to FALSE will compile six routines which take about 1K bytes
of object code.


6.5.2Flag Default Settings

         FLAG              SETTING
         ANSI              TRUE
         ANSI_FUNCT        FALSE (Is set to TRUE on Macintosh disks)
         TITLE_PROMPT      TRUE
         FILE_SAVE         TRUE
         EQ_EVAL           FALSE (Set to TRUE when using "041ee.c")
         NAAUTIL_OBJ       FALSE
         OLD_UNIX_OS       FALSE
         NO_LONG_DOUBLES   TRUE

         EQEVAL_OBJ        FALSE (In "eqeval.c" only)


6.5.3Description of the Routines

The "naautil.c" file contains the following procedures and functions:

     Return           Procedure
     Value       Name            Description
     void         naaerror         -  Exits program with an error message

     double**     dmatrix          -  Allocates a 2-D array of doubles
     float**      matrix           -  Allocates a 2-D array of floats
     double*      dvector          -  Allocates a 1-D array of doubles
     float*       vector           -  Allocates a 1-D array of floats
     int*         ivector          -  Allocates a 1-D array of integers

     void         free_dmatrix     -  Frees the allocated 2-D array memory
     void         free_matrix      -  Frees the allocated 2-D array memory
     void         free_dvector     -  Frees the allocated 1-D array memory
     void         free_vector      -  Frees the allocated 1-D array memory
     void         free_ivector     -  Frees the allocated 1-D array memory

     int          printf2          -  Like printf(), but writes to a file as well
     void         NAA_do_first     -  NAA initialization procedure
     void         NAA_do_last      -  NAA final procedure

Some of these functions can be found in the book "Numerical Recipes in C".  They have been tailored
for "Numerical Analysis Algorithms in C."


naaerror():

This Numerical Analysis Algorithms Error handler prints error messages then exits the program to the
operating system.  It is used by most of the routines found in "naautil.c", "naautil2.c" and "naautil3.c" as
well as in several of the algorithms.


dmatrix():

"Naautil.c" defines five routines for allocating 1-D and 2-D arrays.  These are:

     ivector()   -  Allocates a 1-D array of integers
     vector()    -  Allocates a 1-D array of floats
     dvector()   -  Allocates a 1-D array of doubles
     matrix()    -  Allocates a 2-D array of floats
     dmatrix()   -  Allocates a 2-D array of doubles

These routines are often used instead of conventional arrays.  For example:

     double **A;
     A = dmatrix(0,9,0,11);        /* Dynamic method */

replaces

     double A[10][12];             /* Array method */

These simple routines are used for three reasons: speed, flexibility, and efficiency.

Speed:
For the 2-D array above, referencing two pointers (2 adds) to obtain a value is usually faster than using
an add and a multiply (1 add + 1 multiply) inherent when indexing arrays.  The array "A" is used
identically in both situations.  To obtain this speed, a few more bytes of memory are used to store a row
of pointers.

Flexibility:
With the array method, the number of elements for each dimension are specified.  The above example
uses 10 rows and 12 columns.  These must be referenced from 0 to 9 and 0 to 11 respectively.  With the
dmatrix() routine, the RANGES of the elements for each dimension are specified.  This makes it easier
to work with arrays which are not referenced from 0 to n-1.  Even negative ranges may be specified,
such as dvector(-2,3).

For example, assume we need to sum five elements from 5 to 10.  The dvector() routine could be used
to allocate storage space as follows:

     double *B;
     B = dvector(5,10);

The sum of i from 5 to 10 could be easily implemented with:

     for (i=5;i<=10;i++)
       sum = sum + B[i];

Efficiency:
As seen by the above implementation, B stores only 6 elements.  If we used "double B[6];" (the array
method) we would be required to adjust the index, i, or to just declare B with 11 elements "double
B[11];" for readability.  This would waste 5 elements!  The matrix and vector routines never waste
variables since you only declare what you will use.

The matrix and vector routines call calloc() to dynamically allocate memory.  This means a program
which operates on an array of n x n elements needs to allocate only n x n elements.  With the array
method, the largest anticipated array must be declared which is usually wasteful (consider A[100][100] for
a simple 4 x 4 matrix operation!).

"Naautil2.c" contain more matrix and vector routines for other variable types.  It also defines cube
routines (like dcube()) for 3-D matrices.  These are fast but utilize an extra array of pointers as a trade
off.  "Naautil3.c" contain vector, matrix and cube routines for complex data types.

If your older C compiler does not have calloc() implemented, use "calloc.c" inside the UTIL sub-
directory.  Malloc() could also be used only if every vector, matrix and cube element is initialized to zero
before using them in each algorithm.


free_dmatrix():

Every vector, matrix, and cube routine has a free_ routine to match it.  The free_ routines, like
free_dmatrix(), de-allocate the memory allocated by the vector, matrix, and cube routines.  These are
particularly useful if the algorithms are to be converted into stand-alone functions.  Some older compilers
require that the free_ routines be called in reverse order from the vector, matrix, and cube routines
which allocated the memory blocks.  This reverse ordering style has been used with all of the algorithms.


printf2():

This simple routine works exactly like printf(), but it sends its output to a file as well.  The output file is
the one defined at the top of each algorithm (char *outfile), which gets assigned to the file pointer
"file_id."  It is used frequently in the algorithms to make the source code shorter and easier to read.  It
uses variable length arguments which are often non-portable to non-ANSI compliant compilers.

Two separate versions of this routine are provided.  The first uses <varargs.h> as the header file and is
included for older UNIX C compilers.  The second uses <stdarg.h> as the header file and is ANSI
compliant.  Only one of these routines can be used at a time.  The OLD_UNIX_OS flag determines
which routine is selected, assuming the FILE_SAVE flag is set to TRUE.


NAA_do_first():

This routine is used in every algorithm as the first executable statement.  It performs four main functions
and is dependant upon several flag settings:

1.   Opens the output file for writing (if FILE_SAVE == TRUE)
2.   Prints the "Numerical Analysis Algorithms in C" banner
3.   Prompts for an optional title (if TITLE_PROMPT == TRUE)
4.   Prompts for the use of the Equation Evaluator routines and gets the equation (if
     EQ_EVAL == TRUE)


NAA_do_last():

This routine is used in every algorithm as the last executable statement.  It simply closes the output file
opened by NAA_do_first() and informs the user that a file has been created.  This routine is used only
when the FILE_SAVE flag is set to TRUE.


6.6  Using Naautil.c as Object Code

Each of the algorithms use the file "naautil.c."  Both the "naautil.c" and "eqeval.c" files can be easily
compiled into object code once and then used thereafter ("naautil.c" includes "eqeval.c" if the EQ_EVAL
flag is set to TRUE).  This can save hours of recompilation time, especially when using many algorithms
over a period of time, like for a numerical methods course.  The below sub-sections describe this
procedure for different computer systems.  The files described in Section 7.3 - "Time-Saving Batch, Script
and Command Files" contain commented-out code to do this as well.

Note that if any flags are changed in "naautil.c", then it must be recompiled into object code again before
the changes can take effect.  This includes changing the TITLE_PROMPT, FILE_SAVE, and
EQ_EVAL flags.


6.6.1MS-DOS

Object code files in MS-DOS have a ".OBJ" extension.  To create object code, do the following:

1.   Set the NAAUTIL_OBJ flag to FALSE in "naautil.c"

2.   Compile "naautil.c" into object code by typing the following command at the DOS prompt: 
     (assumes Microsoft C 5.0)

         C:\NAA42> CL /c NAAUTIL.C

3.   Set the NAAUTIL_OBJ flag back to TRUE in "naautil.c"

4.   From now on, compile the algorithms into object code, then link "naautil.obj" to them.  For
     example, using "041.c", type:

         C:\NAA42> CL /c 041.C
         C:\NAA42> CL 041 NAAUTIL

     The first command creates "041.obj" while the second command links it to the "naautil.obj" object
     file to form the executable "041.exe."


6.6.2UNIX

Object code files for UNIX have a ".o" extension.  To create object code, do the following:

1.   Set the NAAUTIL_OBJ flag to FALSE in "naautil.c"

2.   Compile "naautil.c" into object code by typing the following at the shell prompt:

         % cc -c naautil.c 

3.   Set the NAAUTIL_OBJ flag back to TRUE in "naautil.c"

4.   From now on, compile the algorithms along with "naautil.o." For example, using "041.c", type:

         % cc 041.c -o 041 naautil.o -lm


6.6.3Macintosh

Object code files for THINK C on a Macintosh are indicated in the project window by a non-zero size
after the source file's name.  To create the object code, do the following:

1.   Set the NAAUTIL_OBJ flag to FALSE in "naautil.c"

2.   Compile "naautil.c" into object code.

3.   Set the NAAUTIL_OBJ flag back to TRUE in "naautil.c"

4.   From now on, compile the algorithm into object code, then link the "naautil.c" object code to it.

You may have trouble if the compiler asks to bring the "naautil.c" file up to date after step #3 above. 
This may happen since setting the NAAUTIL_OBJ flag back to TRUE in "naautil.c" marks it as no
longer current.  Bringing the folder up to date, including "naautil.c", would remove the routines from the
object code compiled in step #2.


6.6.4VAX/VMS

Object code files for VAX/VMS have a ".OBJ" extension.  To create the object code, do the following:

1.   Set the NAAUTIL_OBJ flag to FALSE in "naautil.c"

2.   Compile "naautil.c" into object code by typing the following at the VMS prompt:

         $ CC /G_FLOAT NAAUTIL.C 

3.   Set the NAAUTIL_OBJ flag back to TRUE in "naautil.c"

4.   From now on, compile the algorithm into object code, then link "naautil.obj" to it.  For example,
     using "041.c", type:

         $ CC /G_FLOAT 041.C
         $ LINK 041, NAAUTIL, LNK$LIBRARY/LIB, LNK$LIBRARY_1/LIB

     The first command creates "041.obj" while the second command links it to the "naautil.obj" object
     file to form the executable "041.exe."


6.7  Supporting C Source Code Usage List

The list below outlines the support files used by each chapter:

                                COMPLEX.C             ROUND.C
                                   and                  and
Chapter  NAAUTIL.C  NAAUTIL2.C  NAAUTIL3.C  GAUSSJ.C  TRUNC.C EQEVAL.C
---------------------------------------------------------------------- 
  1         X                                                    X
  2         X                       X                            X
  3         X                                                  X       X
  4         X                                            X       X
  5         X                                                    X
  6         X                                  X         X
  7         X                                            
  8         X           X           X          X                 X
  9         X                                  X         
  10        X                                  X
  11        X                                  X
  12        X           X                                        X

File usage by name:

     NAAUTIL.C   - All .C files
     NAAUTIL2.C       - 081.C and 125.C    
     NAAUTIL3.C       - 027.C, 028A.C, and 081.C
     COMPLEX.C   - Used in NAAUTIL3.C only
     GAUSSJ.C    - 060B.C, 080B.C, 093.C, 101.C, 101A.C, 102.C, 116.C, 125.C and 129A.C
     ROUND.C          - 031B.C, 040D2.C, 061B.C, 061C2.C, 061D2.C, 062B.C, 063B.C, 074.C,
                      and 095D.C
     TRUNC.C          - Not used.  May replace ROUND.C in the homework exercises for
                      chopping arithmetic.
     EQEVAL.C    - See Section 8.8 for a list.


6.8  "Numerical Analysis" Text Errors and Corrections

This section lists a few errors encountered in the texts as the algorithms were being programmed into C. 
Many of the algorithms will not work correctly without these corrections.  The errors are listed separately
for the third and fourth editions of the text.  Perhaps a more complete list of corrections may be
obtained from the publisher, PWS-Kent Publishing Company, 20 Park Plaza, Boston, Massachusetts 
02116.


6.8.13rd Edition Errors

                          TEXT ERRORS AND CORRECTIONS
                                      for
                     "Numerical Analysis", third edition,
                  Richard L. Burden & J. Douglas Faires, 1984


Page#    Location          Fix
----------------------------------------------------------------------
345      Algorithm 6.5     In Step 7, only swap a few elements in matrix
                           L.  Use: For k = 1 to i-1, swap L(p,k) with
                           L(i,k).  This does not apply to matrix A.

472      Algorithm 8.9     Comments say: OUTPUT A(n-1).  (Could
                           over-write A.)  It should say: ...           
                           (Do not over-write A.)  Over-writing A will
                           give different answers.  Use A1 for A(k) and
                           A2 for A(k+1).

                           At Step #10, 5th line, Don't indent "set
                           a(l,l) = a(l,l) - 2*v(l)*z(l);"

514      Algorithm 9.3     From --> Step 5:  g3 = G(x - ‡3*z).
                           To ----> Step 5:  g3 = G(x + ‡3*z).

                           From --> Step 13:  Set x = x + ‡*z.
                           To ----> Step 13:  Set x = x - ‡*z.

658      Answers p. 484    The answer to 1 e) should be:

                           [ 4      0         0         0    ]
                           [ 0      4     1.414213      0    ]
                           [ 0  1.414213      4     1.414213 ]
                           [ 0      0     1.414213      4    ]


6.8.24th Edition Errors

                          TEXT ERRORS AND CORRECTIONS
                                      for
                     "Numerical Analysis", fourth edition,
                  Richard L. Burden & J. Douglas Faires, 1988



Page#    Location          Fix
----------------------------------------------------------------------
79       Algorithm 2.7     From --> Step 1:  i = 2.
                           To ----> Step 1:  i = 3.

                           From --> Step 4:  E = b + d;
                                             E = b - d;
                           To ----> Step 4:  E = b + D;
                                             E = b - D;
                           (Third edition used d where D is now.)

273      Algorithm 5.5     Steps 17, 18 and 19 are indented one level too
                           far.  This tends to mislead programming
                           efforts.

372      Middle            From --> Step 10  For ... ‰ l(i,j) * x(j)
                           To ----> Step 10  For ... ‰ l(j,i) * x(j)

         Bottom            From --> Step 11 For ... ‰ l(i,j) * y(j)
                           To ----> Step 11 For ... ‰ l(j,i) * x(j)

370      Algorithm 6.5     Add a Step 0 to initialize matrix L as an
                           identity matrix.  IE - 0's every where except
                           for 1's on the diagonal elements.

                           From --> Step 2  ... set v(j) = a(i,j) * d(j)
                           To ----> Step 2  ... set v(j) = l(i,j) * d(j)

                           From --> Step 3  ... ‰ a(i,j) * v(j)
                           To ----> Step 3  ... ‰ l(i,j) * v(j)

                           From --> Step 4  ... ‰ a(j,k) * v(j) ...
                           To ----> Step 4  ... ‰ l(j,k) * v(j) ...

478      Algorithm 8.1     Step 1  ... zeta = e(„*i/m) is a definition
                           (used in Step 3), not a step to implement as
                           code.

                           At Step 8, K1 is never used, just defined.

479      Bottom            From --> + 0.02870726 cos 8z - ...
                           To ----> + 0.05741474 cos 8z - ...   (double
                           it)

494      Algorithm 9.1     Swap Step 6 with Step 7.

501      Algorithm 9.3     Swap Step 7 with Step 8.

514      Algorithm 9.5     Add a modification to Step 7:
         Modifications     From --> Set PROD = SUM V(i) * U(i).
                           To ----> Set PROD = SUM V(i) * (U(i) + Y(i)).
                           See Algorithm 9.5C for the correct
                           implementation.

547      Algorithm 10.2    Add to the end of Step 3:  k = k + 1.

548      Algorithm 10.2    From --> Step 8 ... (Note: ... (S_k + A...) )
                           To ----> Step 8 ... (Note: ... (S_k - A...) )

554      Algorithm 10.3    From --> Step 1  Set k = 0.
                           To ----> Step 1  Set k = 1.

555      Algorithm 10.3    Indent Step 7 and Step 8.

                           Step 12 is different from the third edition of
                           text.

653      Algorithm 12.5    From --> Step 12 ... a(l)(l) = alpha(l)(l) +
                           z...
                           To ----> Step 12 ... alpha(l)(l) = alpha(l)(l)
                           + z...

                           Steps 11 and 18 have been indented
                           incorrectly.
                           From -->  If ...
                                         If ...
                                             else ...
                                         else ...
                                             if ...
                           To ---->  If ...
                                         If ...
                                         else ...
                                     else ...
                                         if ...

709      Answers p. 514    The answer to 3 c) should be:

                  [      5    -4.949747468  -1.432078021  1.564976850 ]
                  [ 1.414213562     -2       2.485551468  1.822644754 ]
                  [      0     5.431390246  -1.423728814  2.648654214 ]
                  [      0           0      -1.593986473  5.423728814 ]


6.9  Watch for These Run-Time Errors

On occasion, run-time errors may occur.  Run-time errors are errors which occur as a program is being
executed.  Most run-time errors are legitimate and can be easily corrected.  These next few sub-sections
outline the most common errors and how to correct them.


6.9.1Stack Space

Several of the programs require more stack space than the others.  The following programs require a
stack larger than 2K bytes:

     028A.c       - Complex Polynomial Solver (CPOLY)
     056.c        - Extrapolation
     081.c        - Fast Fourier Transformation

In Microsoft C 5.0 with MS-DOS, this problem is solved by specifying a larger stack size to the linker. 
For example:

     C:\NAA42> CL 028A.C /link /ST:4096     - For a 4K byte stack in decimal
or
     C:\NAA42> CL 028A.C /F 1000                     - For a 4K byte stack in
                                                     hexidecimal


6.9.2Division By Zero

Division by zero is a common error for fixed-point algorithms and for equations using division. 
Algorithms 2.2 and 10.1A are particularly susceptible to fixed-point errors (x = g(x)).  Fixed-point errors
can usually be corrected by solving for a different x = g(x) in the equation.

Division by zero can occur in algorithms like Algorithm 4.1 - Composite Simpson's Rule.  Trying to
integrate the integral below would cause this error to occur due to the lower bound being zero.

         Ù1
         |  1/x dx
         ı0

This problem can sometimes be corrected by breaking the integral up into parts, making a "u"
substitution, or by making zero a small value (try DBL_EPSILON as defined in <float.h>) and accept
the reduced accuracy errors.


6.9.3Null Pointer Assignments

If arrays created by the "naautil*.c" vector, matrix, and cube routines are referenced outside their legal
ranges, the "Null Pointer Assignment" error may occur.  Incorrect use of the free_ routines, such as
free_dmatrix(), will also cause this error.

For some strange reason, there is an error like this in Algorithm 12.5 with Microsoft C 5.0.  To correct
this particular problem, the free_dmatrix() routine was simply commented out without introducing errors
to the algorithm.


6.9.4No Disk Space

The "No Disk Space" error occurs when a disk is full or when the disk is write-protected.  This can be
corrected by either removing unnecessary files from the disk (especially executables) or by removing the
write-protect sticker or tab from the disk.


6.9.5Floating-Point Accuracy

Computers inherently round all floating-point numbers.  They are usually only as accurate as the largest
word size on the computer or by the size of the internal registers of the math processor chip.  See the
system header file <float.h> for your compiler's accuracy limits.

Listed are some typical values defined in <float.h>:

     FLT_DIG      6        - decimal digits of precision for floats
     DBL_DIG      10       - decimal digits of precision for doubles
     FLT_MAX      1E+37    - maximum floating-point number for floats
     FLT_MIN      1E-37    - minimum floating-point number for floats
     DBL_MAX      1E+308   - maximum floating-point number for doubles
     DBL_MIN      1E-308   - minimum floating-point number for doubles

DBL_DIG is used in routines adapted to use "round.c" or "trunc.c", such as Algorithm 6.1C2.  It specifies
a range for the number of significant (SIG) digits you can enter.


6.9.6Program Stuck in an Infinite Loop

The scanf() and getchar() functions are used to get all of the inputs for the "Numerical Analysis
Algorithms in C" algorithms.  They may get stuck in an infinite loop if a letter is entered where a number
is expected, or vise versa.

To correct this problem, exit the program (usually by hitting "[CONTROL] C") then execute the program
again, this time entering the correct responses.  The code needed to check for errors of this nature
would have introduced unnecessary overhead and would have made the programs less readable.


7.   Useful Utilities


The utilities listed below are found in the UTIL sub-directory on the distribution diskettes.  None of
these utilities are absolutely necessary, but they may make life easier on your part if you use them. 
"Convert.c" will make the algorithms have respectable looking output if uploaded to non-MS-DOS
computer systems.  "List.com" is a handy tool for quickly viewing the output files created by these
programs.  Several files are also included to make compiling and running these algorithms a little easier.


7.1  Convert.c - Converting Files from Extended ASCII to
     Standard ASCII

Past versions of "Numerical Analysis Algorithms in C" came in an extended ASCII version (v4.1) and a
standard ASCII version (v4.11).  "Convert.c" was written to eliminate the need for having two different
versions.  Macintosh disks ship with standard ASCII only.


7.1.1Why Convert.c is Needed

Many programs use the extended ASCII character set available on MS-DOS computers.  These extra 128
characters may translate into garbage when uploading files onto UNIX or VAX computers.  Standard
ASCII uses 7-bits per character while extended ASCII uses 8-bits per character.  When extended ASCII
characters are uploaded to standard-ASCII-only platforms, the 8th bit is masked off (set to zero)
converting them into 7-bit ASCII characters.  To avoid the ill effects of this masking, this program has
been provided.  It converts any MS-DOS text file into standard-ASCII-only files, making the appropriate
character substitutions.

Failure to use "convert.c" may produce results like those shown below after the files are uploaded to a
non-MS-DOS platform:

    normal         w/ convert.c   w/out convert.c      w/out convert.c
                                    7-bit ASCII          8-bit ASCII

     Ù „              [ PI             t c              \364 \343
     ≥ f(x)           | f(x)           3 f(x)           \263 f(x)
     ı ‡              ] alpha          u `              \365 \340
                                                        (in octal)

See the Examples Book for the C source code for "convert.c."  This file contains a table called
ASCIIlist[] which contains the extended ASCII characters and their suggested standard ASCII
substitutions.  This table can be easily modified by the user, but doing so requires "convert.c" to be
recompiled.  "Convert.c" has been compiled into "convert.exe" for MS-DOS computers and is shipped
with the distribution diskettes.

The advantages of running the files through convert is that they can be ported to any machine, especially
UNIX systems, with terminals only capable of displaying standard ASCII.  The disadvantages are that you
no longer have the proper symbols like those used in chapter 4 of the text for integration, or Ú, Û, x˝,
and numerous Greek symbols often used in mathematics.

Examples of the most commonly used extended ASCII characters and their closest substitutions are
shown below:

         ASCII                              ASCII
         Number   Char     Substitute       Number   Char     Substitute
         129      Å        u                238      Ó        E or epsilon
         179      ≥        |                240              =
         224      ‡        alpha            241      Ò        +/-
         225      ·        beta             242      Ú        >=
         227      „        PI               243      Û        <=
         228      ‰        Summation of     244      Ù        [
         230      Ê        mu               245      ı        ]
         232      Ë        phi              247      ˜        =
         235      Î        d or delta       253      ˝        ^2
         236      Ï        oo or infinity


7.1.2How to Use Convert.c

Before using the convert program, MAKE A SET OF BACKUP DISKETTES for "Numerical Analysis
Algorithms in C"!  Convert over-writes the original files with the newly converted files.  Failure to make
a set of backup diskettes will remove the option of ever going back to the extended ASCII version of the
files.  In other words, convert is one-way.

"Convert.c" will convert a single file or a list of files.  To convert a single file, type:

     C:\> CONVERT FILE_NAME

where "file_name" is the name of the desired file, such as "041.c."  To convert a list of files, first create a
list using a standard text editor ("file_name [ENTER]" format), then type:

     C:\> CONVERT -L FILE_NAME_LIST

where "file_name_list" is the name of the file containing a list of file names you desire to convert.

For your convenience, two lists are provided: "LISTALL" and "LISTOUT."  "LISTALL" is a file name list
which contains all of the algorithms, support files, and documentation (except "convert.c").  "LISTOUT"
is a file name list containing all of the algorithm output file names in the OUT sub-directory.  Together
these two file will convert all of the necessary "Numerical Analysis Algorithms in C" files into standard
ASCII files.

To create a standard ASCII set of files, do the following:

1.   Make a set of backup disks.  See your operating system manual for specifics.

2.   Change to the directory containing the algorithms (assume C:\NAA42 in this example).  For
     example:

         C:\> CD \NAA42

3.   Convert all of the files inside the main directory.  Do this by typing:

         C:\NAA42> UTIL\CONVERT -L UTIL\LISTALL

     Wait a few minutes until the conversion is finished.

4.   Now convert all of the files inside the OUT sub-directory.  This step is optional.  Do this by
     typing:

         C:\NAA42\> CD OUT
         C:\NAA42\OUT> ..\UTIL\CONVERT -L ..\UTIL\LISTOUT

NOTE:      The above steps can be done on a non-MS-DOS computer if the files are transferred as
           binary files.  See Section 2.1 - "Uploading to Mainframe Computers" and use the "SET
           BINARY" option of KERMIT.  "Convert.c" will naturally need to be recompiled on the
           new host computer.


7.2  List.com - A Better TYPE Command

"List.com" is an MS-DOS program which acts as a better "TYPE" command.  It uses the arrow keys and
other editing keys to view text files.  "List.com" does not allow you to edit files, just view them.  It is a
public domain program.

To use "list.com" to view the output of Algorithm 4.1, type:

     C:\> LIST 041.OUT

To scroll the text left, right, up or down, use the arrow keys.  Typing 'X' exits "list.com."  Typing '?'
brings up a help menu.  These commands and more are shown at the bottom of the "list.com" screen.


7.3  Time-Saving Batch, Script and Command Files

The files below can be use to simplify how you compile and run these algorithms.  One is included for
Microsoft C 5.0 on an IBM PC, one for UNIX, and one for VMS on a VAX.  The actual commented
files are also listed below:


7.3.1CC.BAT

The batch file "cc.bat" can be used in place of the Microsoft C 5.0 "CL" command under MS-DOS.  It
contains the following:

     CL /Od /qc %1.c
     IF ERRORLEVEL 1 GOTO END
     %1
     LIST %1.OUT
     :END

To use it, type: "C:\> CC 041" where 041 is an algorithm file name.    Be sure to leave off the ".c"
extension.  "Cc.bat" will do the compiling, running, and will list the output file.

Commands are also listed to produce and use "naautil.c" as object code.  Read the comments in this batch
file for further instructions or see Section 6.6 - "Using Naautil.c as Object Code".

Below is a listing of the "cc.bat" batch file:

:*********************************************************************
:  Program:  CC.BAT  (MS-DOS batch file)
:
:  Purpose:
:    Cc.bat is an MS-DOS batch file used for compiling, running and
:    viewing a Microsoft C 5.0 program.  It can be easily altered to
:    allow for linking to "NAAUTIL.OBJ" (with or without "EQEVAL.C"),
:    speeding up the compile time.  Can also be altered to increase
:    the stack size of a program.
:
:  Written By:  Harold A. Toomey
:  Date:        21 Aug 1991
:
:  Example:  C:\> CC 041   where "041.C" is the file name.
:                          (Leave off the .C extension)
:*********************************************************************
:
:  Do a compile and link (CL), disabling optimization (/Od) and
:  invoke the QuickC compiler option (/qc) to shorten the compile
:  time.
:
CL /Od /qc %1.c
:
:  Replace the main line above with the line below if a larger stack
:  is needed.  This allows for a stack size of 4K bytes (/link
:  /ST:4096).  A MUST when compiling algorithms 2.8A, 5.6 and 8.1.  
:
: CL /Od %1.c /link /ST:4096
:
:  Replace the main line above with the two lines below if
:  "NAAUTIL.C" has been compiled and exists as object code
:  ("NAAUTIL.OBJ").  The first line creates %1.OBJ while the second
:  line links %1.OBJ to "NAAUTIL.OBJ" to form %1.EXE.  (Most
:  flexible)
:
: CL /Od /c %1.c
: CL %1 NAAUTIL
:
:
:  Create "NAAUTIL.OBJ" object code by running the below step once.
:  Remember to re-compile "NAAUTIL.C" every time one of its flags
:  are changed.
:
: CL /c NAAUTIL.C
:
:
:  If the program compiled correctly, then run it.  If not, exit
:  this batch file.  Replace "%1" with "%1 < IN\%1.IN" if using the
:  input file for initial testing.
IF ERRORLEVEL 1 GOTO END
%1
:
:  View the program's output file using "LIST.COM".  You may
:  substitute DOS's TYPE command for "LIST.COM."
LIST %1.OUT
:END
:*********************************************************************


7.3.2CCC

The script file "ccc" can be used in place of the "cc" command under UNIX.  It contains the following:

     cc $1.c -o $1 -lm
     $1
     more %1.out

To use it, type: "% ccc 041" where 041 is an algorithm file name.    Be sure to leave off the ".c"
extension.  "Ccc" will do the compiling, running, and will list the output file.  You may want to make
"ccc" a UNIX (csh) script file.  To do this, type "% chmod +x ccc" only once.  The alternative is to
type "% source ccc 041" every time you use "ccc".

Commands are also listed to produce and use "naautil.c" as object code.  Read the comments in this script
file for further instructions or see Section 6.6 - "Using Naautil.c as Object Code".

Below is a listing of the "ccc" script file:

#*********************************************************************
#  Program:  ccc  (UNIX script file)
#
#  Purpose:
#    Ccc is a UNIX script file used for compiling, running, and
#    viewing a mathematical C program.  It can be easily altered to
*    allow for linking to "naautil.o" (with or without "eqeval.c"),
#    speeding up the compile time.
#
#  Written By:  Harold A. Toomey
#  Date:        21 Aug 1991
#
#  Example:  % ccc 041   where "041.c" is the file name.
#                        (Leave off the .c extension)
#*********************************************************************

echo Compiling $1.c

#  Compile the program and name the executable the same as the
#  original file except with no extension.  Links to the math library
#  (located in /usr/lib/libm.a).

cc $1.c -o $1 -lm

#  Replace the above "cc" line with the below "cc" line to link to
#  the pre-compiled "naautil.c" object code file.
#
# cc $1.c -o $1 naautil.o -lm
#
#
#  Create "naautil.o" object code by running the below step once.
#  Remember to re-compile "naautil.c" every time one of its flags
#  are changed.
#
# cc -c naautil.c 
#

#  Run the program
$1

#  View the program's output file
more $1.out
#*********************************************************************


7.3.3VAXCC.COM

The command file "vaxcc.com" can be used in place of the VAX "CC" and "LINK" commands under
VAX/VMS.  It contains the following:

     $ DEFINE LNK$LIBRARY    SYS$LIBRARY:VAXCRTLG
     $ DEFINE LNK$LIBRARY_1  SYS$LIBRARY:VAXCRTL
     $ CC /G_FLOAT 'P1'.C
     $ LINK 'P1', LNK$LIBRARY/LIB, LNK$LIBRARY_1/LIB

To use it, type: "$ @VAXCC 041" where 041 is an algorithm file name.    Be sure to leave off the ".c"
extension.  "Vaxcc.com" will do the compiling and linking as a single command.  The '@' character tells
VMS that "vaxcc.com" is a command file.

Commands are also listed to produce and use "naautil.c" as object code.  Read the comments in this
command file for further instructions or see Section 6.6 - "Using Naautil.c as Object Code".

Below is a listing of the "vaxcc.com" command file:

$! *******************************************************************
$!   Program:  VAXCC.COM  (VAX command file)
$! 
$!   Purpose:
$!     VAXCC.COM is a VAX command file used for compiling and linking
$!     a mathematical C program.  It can be easily altered to allow
$!     for linking to "NAAUTIL.OBJ" (with or without "EQEVAL.OBJ"),
$!     speeding up the compile time.
$! 
$!   Written By:  Harold A. Toomey
$!   Date:        21 August 1991
$! 
$!   Example:  $ @VAXCC 041   where "041.C" is the file name.
$!                            (Leave off the .C extension)
$! *******************************************************************
$!
$!  Define the link libraries to allow the use of the /G_FLOAT
$!  qualifier but not the use of Curses.  These two defines may be
$!  placed into your "LOGIN.COM" file to be performed once at login
$!  time.
$!
$ DEFINE LNK$LIBRARY    SYS$LIBRARY:VAXCRTLG
$ DEFINE LNK$LIBRARY_1  SYS$LIBRARY:VAXCRTL
$!
$!  Compile the program with the floating-point qualifier to create
$!  an .OBJ object file.  Link the object file to create the
$!  executable.
$!
$ CC /G_FLOAT 'P1'.C
$ LINK 'P1', LNK$LIBRARY/LIB, LNK$LIBRARY_1/LIB 
$!
$! *******************************************************************
$!  Replace the above "LINK" line with the below "LINK" line to link
$!  to the pre-compiled "NAAUTIL.C" object code file.
$! 
$! LINK 'P1', NAAUTIL, LNK$LIBRARY/LIB, LNK$LIBRARY_1/LIB
$! 
$! *******************************************************************
$!  Create "NAAUTIL.OBJ" object code by running the below step once.
$!  Rember to re-compile "NAAUTIL.C" every time one of its flags
$!  are changed.
$! 
$! CC /G_FLOAT NAAUTIL.C 
$! 
$! *******************************************************************


8.   The Equation Evaluator Routines


Over two-thirds of the algorithms in "Numerical Analysis Algorithms in C" need to be compiled only
once.  They prompt for all the necessary inputs.  The other one-third of the algorithms contain multiple
modifiable functions, such as F(x).  The C language has no pre-defined procedures to allow functions to
be entered at run-time.  To add these capabilities, a set of procedures have been written.  These routines
are located in the file named "eqeval.c."


8.1  What the Routines Do

Quite simply, the equation evaluator routines allow the user to enter mathematical equations at run-time
rather than having to recompile an algorithm for each unique function.  All of the single function
programs have the equation evaluator routines already implemented into them.  These routines are
activated only if the EQ_EVAL flag is set to TRUE in "naautil.c."  Implementing the equation evaluator
routines require only a few simple steps, as shown below.

A convenient utility program is also provided called "ee.c."  This program can be used to familiarize
yourself with writing equations in the C language.  It can also be used as a command-line calculator
similar to the one the BASIC language provides.  Like C, it uses infix notation.  All math functions
defined in the standard C library header <math.h> are valid.  Unary operators like "+3" and "-3" are
included if the ANSI flag is set to TRUE in "eqeval.c."

To evaluate a function like "f(x) = cos(x + 3.14) - 2", just type:

     C:\NAA42> ee cos(x + 3.14) - 2

Spaces are allowed inside the equations.  Equations can be entered in uppercase or lowercase characters. 
The variables x, y and/or t can also be used inside the equations.  The "ee" program will prompt you for
the values of needed variables.  It also prompts you to evaluate the entered equation again.

Typing "ee" by itself will cause the equation evaluator to prompt for an equation to be entered.

All internal computations are done using floating-point numbers.  Equations are limited to 130 characters
as defined by MAX_LINE_SIZE in "eqeval.c."  This number may be increased to suit your needs.  The
larger it is, the more memory the routines will require.  It was set to 130 since MS-DOS will not accept
more than 128 characters at the DOS prompt.  Many computers have similar limitations.


8.2  How to Insert the Routines into a Program

To implement the equation evaluator routines into a Numerical Analysis program, three simple
modifications are required.

1)   Make sure that the EQ_EVAL flag is set to TRUE in "naautil.c."

         #define EQ_EVAL  TRUE

2)   Add something similar the following lines into the function to evaluate, usually f(x):

         if (eqeval)
            return (eval_eq(x));   /* Use the Equation Evaluator */
         else
            return (sin(x));       /* This is the default function */

     NOTE:       Valid calls to eval_eq() include eval_eq(any_number), eval_eq(x), eval_eq(x,y), and
                 eval_eq(x,y,t).  Eval_eq() is not valid unless at least one argument (parameter) is
                 passed to it.

3)   Just after main(), add something like the following lines to print the correct equation onto the
     screen and into the output file:

         if (eqeval)
            printf2("f(x) = %s", tmpstr);
         else
            printf2("%s", eq_text_f);       /* This is the default text */


8.3  An Example Using Simpson's Rule

See the file "041ee.c" for a descriptive example using Algorithm 4.1 - Simpson's Rule for Integration and
the equation evaluator routines.  This file performs the same as "041.c", but is commented differently.


8.4  Using Eqeval.c As Pre-Compiled Object Code

If you find yourself using the equation evaluator routines in "eqeval.c" rather frequently, you may want
to compile them only once and then link the object code to the programs.  Doing this will save you time
as you compile your modified algorithms.

If "naautil.c" had the EQ_EVAL flag set to TRUE and is being used as object code, go no further with
this section.  The below steps are unnecessary in this situation, since the "naautil.c" object code will
already contain the "eqeval.c" object code.  Otherwise, follow the five steps below:

1)   Set the EQEVAL_OBJ flag to FALSE in "eqeval.c":

         #define EQEVAL_OBJ FALSE

2)   Compile "eqeval.c" into object code.  Do one of the following:

     MS-DOS:          C:\NAA42> CL /c EQEVAL.C       - Creates "EQEVAL.OBJ"
     UNIX:            % cc -c eqeval.c               - Creates "eqeval.o"
     VAX/VMS:    $ CC /G_FLOAT EQEVAL.C              - Creates "EQEVAL.OBJ"

3)   Now set the EQEVAL_OBJ flag to TRUE in "eqeval.c."

         #define EQEVAL_OBJ TRUE

     This keeps the algorithms from re-compiling the equation evaluator routines.  After step 2 above,
     "eqeval.c" should be available in object code to be linked to later.

4)   From now on, compile the algorithms into object code.  Do one of the following, assuming
     "041.c":

     MS-DOS:          C:\NAA42> CL /c 041.C                   - Creates "041.OBJ"
     UNIX:            % cc -c 041.c                           - Creates "041.o"
     VAX/VMS:    $ CC /G_FLOAT 041.C                 - Creates "041.OBJ"

5)   When compiling the algorithms, be sure to link with the "eqeval" object code.  To do so, type one
     of the following:

     MS-DOS:          C:\NAA42> CL 041 EQEVAL                 - Links "041.OBJ"
     UNIX:            % cc -o 041 041.o eqeval.o -lm          - Links "041.o"
     VAX/VMS:    $ LINK 041 EQEVAL                   - Links "041.OBJ"

Under UNIX, steps 4 and 5 can be combined into the single command "cc -o 041 041.c
eqeval.o -lm".

See "cc.bat", "ccc" and "vaxcc.com" in the UTIL sub-directory for ideas on automatically linking object
code to programs.  "cc.bat" is for MS-DOS, "ccc" is for UNIX and "vaxcc.com" is for a VAX.


8.5  Valid Math Operators and Functions

This section lists what the equation evaluator routines will accept and what they will reject.

Valid mathematical operators are:

*        /        %        +       -        +        - (unary)

Invalid mathematical operators are:

**       ^        mod      rem     \        div

Valid mathematical functions are:

abs()             cos()            frexp()           sin()
acos()            cosh()           ldexp()           sinh()
asin()            exp()            log()             sqrt()
atan()            fabs()           log10()           tan()
atan2()           floor()          modf()            tanh()
ceil()            fmod()           pow()

Invalid mathematical functions are;

atof()            atoi()           div()             hypot()
rand()            fsin()           fcos()            ftan()
fasin()           facos()          fatan()           fsinh()
fcosh()           ftanh()

Valid variables are:

x        y        t        (uppercase or lowercase)

Valid number formats are:

3.1415   3.1415e-2         3       .4       

For a brief description of the implemented mathematical operators and functions, see Sections 5.1 and
5.2.


8.6  Sample Equations

Use the "ee" program to enhance your skills at coding mathematical equations in C.  Some examples
might be:

     ee (1+2)*3
     ee 1+2*3
     ee 1 + sin(x*2)
     ee -2+3
     ee pow(3.0,x) - y + t
     ee +1-x
     ee x / y
     ee pow(x,pow(2.0,pow(2.0,y)))


8.7  Possible Error Messages

It is easy to accidentally enter an incorrect equation.  If an invalid equation is encountered, one of
several possible error messages will be printed to the screen.  The program will also immediately abort. 
All possible error messages are listed below:

1.   "ERROR: Parentheses are mismatched."
     Bad Example: "((3)"
     Checks for unmatched parentheses.

2.   "ERROR: Misuse of parentheses."
     Bad Example: "1+2)*(3"
     Another way to catch illegal usage of parentheses.

3.   "ERROR: "()" is not a valid equation."
     Bad Example: "()"
     Handles the special case of nothing enclosed in sets of parentheses.

4.   "ERROR: Unrecognized mathematical operator encountered."
     Bad Example: "3$4"
     Only *, /, %, +, and - operators are allowed.  The '^' symbol, shorthand for pow(), as in "3^x"
     is not supported and is not part of C (catches former Pascal users).

5.   "ERROR: Too many sequential unary operators used."
     Bad Examples: "x - - -3" and "+ -3"
     Can usually have up to two unary operators without errors, such as "3 + -4".  No more than one
     unary operator is allowed to start an equation or to follow a left parenthesis.

6.   "ERROR: Incorrect equation entered.  Check for missing operands."
     Bad Example: "3 * / 4"
     Checks for numbers or functions missing between operators.

7.   "ERROR: Incomplete equation entered."
     Bad Example: "5+"
     Checks for obviously incomplete equations.

8.   "ERROR: Invalid number in equation."
     Bad Example: "3.1e-r"
     See valid number formats above.  They are the same formats accepted by printf("%f", &x);

9.   "ERROR: Invalid function in equation (1)."
     Bad Example: "tangent(x)"
     Checks for excessively large strings.  Currently, any function longer than 5 characters
     (MAX_FUN_SZ) is too long.  You should increase the value assigned to MAX_FUN_SZ in
     "eqeval.c" if you add any new functions longer than 5 characters.

10.  "ERROR: Invalid function in equation (2)."
     Generated if you add more functions but forget to modify isfunct() and/or you forget to define a
     new function ID, such as POW_ID.  You should never see this error message if you do not
     modify the "eqeval.c" source code.

11.  "ERROR: In parser."
     Generated if you add more functions but forget to modify traverse_tree(), defining how the
     functions are to behave.  You should never see this error message if you do not modify the
     "eqeval.c" source code.


8.8  List of Algorithms Using the Equation Evaluator Routines

The 34 algorithms below require only one function to be evaluated.  They each have the equation
evaluator routines already implemented into them.  These algorithms need to be compiled only once,
assuming the EQ_EVAL flag was set to TRUE in "naautil.c.".

         011B.c   031.c    041B.c  051B.c   080B.c
         021.c    031B.c   041C.c  052.c    081.c
         022.c    031C.c   041D.c  054.c    122.c
         024.c    032.c    042.c   054B.c   122B.c
         024B.c   034.c    043.c   054C.c   122C.c
         025.c    035.c    043B.c  055.c    123.c
         027.c    041.c    051.c   056.c

The 37 algorithms listed below require the input of more than one function.  Using the equation
evaluator on these algorithms is not recommended, since only one of the multiple equations can use the
equation evaluator routines at a time.

         023.c    044C.c   101.c   113.c    125.c
         024C.c   045.c    101A.c  113B.c   126A.c
         033.c    045B.c   102.c   114.c    127A.c
         040B1.c  045C.c   103.c   114B.c   128A.c
         040B3.c  053.c    103B.c  115.c    129A.c
         040C1.c  057.c    111.c   116.c
         044.c    057B.c   112.c   121.c
         044B.c   058.c    122B.c  124.c

The remaining 45 algorithms do not need function equations (or the equation evaluator) and need to be
compiled only once.  Most of these perform matrix operations, where the dimension of the matrices are
entered at run-time and the memory is dynamically allocated.


8.9  Limitations

The limitations of the equation evaluator routines are as follows:

1.   Only one function can use the routines per program.  This means algorithms requiring only a
     single function, like f(x,y), will benefit while algorithms requiring two or more functions, like
     f1(x,y) and f2(x,y) in the same algorithm, will not benefit.

2.   There is a 130 character limit for the equations.  This can be easily overcome by increasing the
     value of #define MAX_LINE_SIZE in "eqeval.c." 

3.   Up to 3 variables can be used in the equations.  These are: constants, x, y, and/or t.  These will
     cover all algorithms in this package which contain only a single function.  f(x) and f(y,t) are the
     most common uses of these variables.

4.   These routines require the use of variable length arguments.  Variable length argument functions
     can be very non-portable.  If your compiler does not support variable length argument lists like
     "eval_eq(x, ...)", you may need to fix the function eval_eq() to require all three arguments
     (parameters) to be passed, such as eval_eq(x,y,t).  Do this by replacing eval_eq() in "eqeval.c"
     with:

         double eval_eq(x, y, t)
         double x, y, t;
         {
           eq_eval_x = x;
           eq_eval_y = y;
           eq_eval_t = t;
           traverse_tree(eq_node[0]);
           return(eq_node[0]->value);
         }

     This alteration requires that all calls to eval_eq() pass three values, such as:

           f(x)   --> eval_eq(x,0,0)
           f(y,t) --> eval_eq(0,y,t)


8.10  Trade-Offs

PROS:
1.   Adds long-term flexibility.  Algorithms which use the equation evaluator routines need to be
     compiled only once.

2.   Faster than recompiling different functions, like f(x), several times.

CONS:
1.   May evaluate the function slightly slower than hard-coded functions.  This may only become
     noticeable for very large problem sets.  Uses a binary tree to evaluate the function rather than
     the faster and more optimized in-line mathematical code generated by the compiler.

2.   Will make the executable code larger.  The equation evaluator routines can add up to 7K bytes
     of code to the executables.


9.   Portability


It has been said that C is both "a relatively low level system implementation language" and that "C is a
portable language."  These two statements seem contradictory.  The portability of C is very dependant
upon the operating system, the compiler and even the version of the compiler running the programs. 
This chapter attempts to cover some of the necessary issues faced when "porting" these algorithms to
other computer platforms and compilers.  For further references about portability, an excellent book
detailing these issues is "Portability and the C language", by Rex Jaeschke, 1988.

These algorithms are currently being used on a wide variety of computer systems and compilers.  This
chapter covers those platforms familiar to the programmer, namely: MS-DOS on IBM PCs, UNIX
workstations, Macintoshes, and VAX mainframes.  These programs have been developed with these
platforms in mind, especially MS-DOS.  Care has been taken to keep these programs working on older
K&R compliant C compilers as well as the newer ANSI C compilers and even C++ compilers.  If your
compiler is fully ANSI C compliant, then there should be no problems getting these programs to work on
your computer.

Whenever a peculiar problem arose on a non-ANSI compiler, the best means of working around the
problem was chosen while still maintaining portability.  This usually took on the form of a special flag in
"naautil.c."  The sections below cover some of the problems encountered and how they are or were
overcome.

If you are unable to get these programs to run on your computer system after reading this chapter and
trying all means available to you, you are welcome to call the programmer (Care-Free Software) for help
or return this package for a full refund.


Case Sensitivity

When uploading these programs to another machine, remember that unlike FORTRAN, C is case
sensitive!  These algorithms will not work if they are translated into all uppercase characters.  This
situation is most likely to occur when using communications software to transfer the files to a mainframe
computer.


Memory Allocation

"Numerical Analysis Algorithms in C" relies heavily upon the functions calloc() and free().  These are
found inside most of the routines in "naautil.c", "naautil2.c" and "naautil3.c".  "Naautil.c" is used in every
algorithm.  If calloc() doesn't work, neither will the algorithms.  Calloc() usually requires the <stdlib.h>
header file.  Non-ANSI C compilers may use <malloc.h> or <alloc.h>.

If these do not do the trick, use the file "calloc.c" found in the UTIL sub-directory.  The comments inside
this file explain how to use and implement it into these programs.  They provide the functions
naacalloc() and naafree() as replacements for calloc() and free().  Few users should ever need these
replacement routines.


9.1  C vs ANSI C

The C language adopted a standard (ANSI C) in December 1989.  Before this standard, the definitive
book on C was "The C Programming Language", first edition, by Brian W. Kernighan and Dennis R.
Ritchie, the creators of C.  This older style of C is also referred to as K&R style.  For a simple summary
of the changes from C to ANSI C, see appendix C of the second edition of "The C Programming
Language."

ANSI C is guaranteed to accept any strictly conforming program to generate portable code.  To obtain a
copy of the ANSI C language specification, contact:

     American National Standards Institute
     1430 Broadway
     New York, NY  10018
     (212) 642-4900

Ask for ANSI X3.159-1989.  The cost is fixed at $50.00 plus approximately $6.00 for handling.


Function Prototyping

One of the features first used in C++ and quickly adopted into ANSI C is the use of function
prototypes.  Function prototypes declare a function, its expected input types and its expected output
type.  This is helpful for ensuring that functions are being used correctly.

Most older C compilers do not understand the newer type-checking prototype statements like:

     double *dvector(int, int);             /* ANSI Style */
or
     double *dvector(int a, int b);         /* ANSI Style */

These older compilers expect statements like:

     double *dvector();                     /* K&R Style */

The new method of prototyping is preferred but not usually necessary.  Function prototypes are usually
placed at the top of a program or inside header files.  To use the older method of prototyping, simply
change the ANSI flag to FALSE in "naautil.c."  The default setting is TRUE for ANSI-compliant C
compilers.


Function Declarations

Functions can be declare in two different ways in ANSI C.  Examples of these two methods are given
below:

         OLDER K&R STYLE           NEWER ANSI STYLE
         int max(a,b)              int max(int a, int b)
         int a,b;
         {                         {
           ...                       ...
         }                         }

Both styles are allowed in ANSI C, however the ANSI style is preferred.  "Numerical Analysis
Algorithms in C" uses the older K&R style to retain compatibility.  You may restructure the functions to
conform with the newer ANSI style if necessary.  Setting the ANSI_FUNCT flag to TRUE causes
several key functions to use the newer ANSI style function declaration.  This is required when using
THINK C 4.0 on a Macintosh.


9.2  IBM PCs and MS-DOS


Microsoft C 5.0

All of these programs were developed using Microsoft C 5.0 with the small model library.  If you use
anything other than the small model, add "#include <malloc.h>" to the top of "naautil.c" and anywhere
else where alloc() and calloc() are used.  <malloc.h> is not part of ANSI C.  Use <stdlib.h> to replace
it if possible.

Also, this compiler allows spaces to precede a "#define" statement.  This is not standard and will not
work on several UNIX compilers.  This problem has been corrected.  No leading white spaces are
present before "#define" statements in this version, even though using them would have made some of
the code easier to read.

Compile using the /Za switch to check for ANSI compatibility.


Turbo C 2.0

No reported incompatibility problems.


9.3  UNIX Workstations

These programs should work on all UNIX workstations.  If the version of UNIX is somewhat old, you
may need to set the OLD_UNIX_OS flag to TRUE in the "naautil.c" file.  It allows the use of
<varargs.h> for variable length argument lists instead of <stdarg.h>.


Using extended ASCII

Many of the algorithms use the extended ASCII character set available on MS-DOS computers.  These
get turned into unexpected characters when uploaded to many UNIX machines.  See Section 7.1 -
"Convert.c - Converting Files from Extended ASCII to Standard ASCII" if this becomes a problem.


Variable Length Argument Lists

New to version 4.2 is the use of variable length argument lists.  The printf2() command defined in
"naautil.c" and the eval_eq() command defined in "eqeval.c" are the only places where variable length
argument lists are used.  The "printf2()" function simply prints to two different places; to the screen and
to a file.  It requires the ANSI header file <stdarg.h>.  

The header <stdarg.h> is an ANSI C invention modeled closely on the UNIX <varargs.h> capability. 
Since ANSI C uses a slightly different approach, the new header <stdarg.h> was designed rather than
retaining <varargs.h> with a changed meaning.  It is possible that some compilers will provide both of
these headers, while others might provide only one or the other.

If <stdarg.h> is provided, then use it over <varargs.h>.  If only <varargs.h> is provided, then use the
alternate printf2() inside "naautil.c" by setting the OLD_UNIX_OS flag to TRUE.  See the comments
inside the printf2() functions in Appendix B on how to use them.


AT&T UNIX PC

Some versions of this C compiler (older K&R style) do not like multiple assignment expressions like "a =
b = 4;".  To overcome this problem, just break these statements up like "b = 4; a = b;".  All of these
kinds of statements have been found and corrected in version 4.2.  This compiler was used at Brigham
Young University's Numerical Analysis Laboratory in 1989.


HP 9000/300

Had an error when not leaving a space between an equal ('=') and a minus sign ('-').  Example:  for (i=-
1;i<=N;i++).  Fixed it by adding a space.  Example:  for (i= -1;i<N;i++).  This is probably due to an
ambiguity with the obsolete usage of "=-" for "-=", such as with x -= 1; to represent x = x - 1;.  All
occurrences of the above problem have been corrected in all of the algorithms.


Sanyo ICON

Version 4.0 was ported successfully onto a 68020 based ICON in use at the Electrical Engineering
Department at Brigham Young University.

It had an older compiler that did not implement "void."  This can be circumvented by adding "#define
void int" or "typedef int void;" to the top of "naautil.c."


Silicon Graphics 4D Series and the MIPS Compiler

Have had no problems running on a Silicon Graphics 4D/85GT using IRIX 3.3.1 and a MIPS C compiler.

Compile using the "-ansi" switch to check for ANSI compatibility.  The "-fullwarn" switch may also be
helpful in producing portable code.


9.4  Macintosh Computers

"Numerical Analysis Algorithms in C" versions prior to 4.2 required command line redirection, such as
"041 > 041.OUT".  This presented a problem, since Macintoshes do not have a command line!  A quick-
and-dirty fix in the past has been to add the "ccommand()" function just after main().  Example:

           (Use the "ANSI" library in THINK C 4.0)
         #include <console.h>               /* Needed header file */
         int ccommand (char ***p);          /* Function prototype */

         main(int argc, char **argv)
         {
           ...                              /* Declare variables first */
           argc = ccommand(&argv);          /* Invokes a command line  */
           ...                              /* Continue w/the program  */
         }

This was only necessary for creating an output file and has been corrected.  All of the programs have
been rewritten to no longer need redirection, or the "ccommand()" function.  


9.5  VAX Mainframes

Many of the algorithms need the C Library function "tolower()".  Be sure it is implemented correctly. 
You may need to include the file <ctype.h> along with <stdlib.h>.  "Tolower()" is usually implemented
as a function and as a macro.  The function in <stdlib.h> is preferred over the macro in <ctype.h>.

Another problem encountered was having the underscores ("_") stripped from file names after being
transferred via kermit (with ProComm) to a VAX.  All underscore characters have been removed from
the file names eliminating this problem.

If your VAX C compilers does not perform floating-point printing correctly in the printf() function,
specify the /G_FLOAT qualifier to the "CC" command.

Some VAX compilers do not support the "long double" type.  This type is used in "naautil2.c" but is
currently not used in any of the algorithms.  Routines using "long double" types in "naautil2.c" where
placed there for completeness and for future higher precision needs.  To eliminate any compiler errors or
warnings, set the NO_LONG_DOUBLES flag to TRUE in "naautil.c."


9.6  Tested Compilers

The following compilers have successfully run all of the "Numerical Analysis Algorithms in C" v4.2
programs:

MS-DOS:
     1.  Microsoft C 5.0
     2.  Turbo C 2.0

UNIX:
     1.  MIPS C Compiler for Silicon Graphics 4D Workstations

Macintosh:
     1.  THINK C 4.0        (Set ANSI_FUNCT == TRUE)

VAX/VMS:
     1.  VAX C v3.1
     2.  VAX C v3.2

The following additional compilers have successfully run previous versions of the "Numerical Analysis
Algorithms in C" programs:

UNIX:
     1.  AT&T UNIX PC
     2.  HP 9000/300
     3.  Sanyo ICON

VAX/VMS:
     1.  MicroVAX


10.    Sample License Agreements


"Numerical Analysis Algorithms in C" is available for individuals, universities and corporations.  These
sample license agreements are provided as a reminder of your rights when using these programs.  They
also allow the legal departments of universities and corporations to determine the scope of a site license
before actually purchasing one.  Personalized license agreements are sent with each order.


10.1  Individual License Sample


                     "NUMERICAL ANALYSIS ALGORITHMS IN C"

                          INDIVIDUAL LICENSE (SAMPLE)

This Individual License is issued to <INDIVIDUAL'S NAME HERE>, on <DATE>, by CARE-FREE
SOFTWARE under permission of Harold A. Toomey, the proprietary owner.

Software Version:  4.2
License Number:    YMMDDX-I   


                           NOTIFICATION OF COPYRIGHT

THIS SOFTWARE PROGRAM PACKAGE ("SOFTWARE") IS A PROPRIETARY PRODUCT OF
HAROLD A. TOOMEY AND IS BEING DISTRIBUTED BY CARE-FREE SOFTWARE.  AS
SUCH, IT IS PROTECTED BY COPYRIGHT LAWS AND INTERNATIONAL TREATY.  YOU
("INDIVIDUAL") MUST TREAT THE SOFTWARE LIKE ANY OTHER COPYRIGHTED
MATERIAL, EXCEPT THAT YOU MAY EITHER MAKE ONE COPY OF THE SOFTWARE
SOLELY FOR BACKUP OR ARCHIVAL PURPOSES, OR YOU MAY PLACE THE SOFTWARE
ON A SINGLE HARD DISK, PROVIDED THAT YOU KEEP THE ORIGINAL SOFTWARE
SOLELY FOR BACKUP OR ARCHIVAL PURPOSES.  COPYRIGHT LAWS PROHIBIT MAKING
ADDITIONAL COPIES OF THE SOFTWARE FOR ANY OTHER REASON.
 

                     SOFTWARE INDIVIDUAL LICENSE AGREEMENT

READ THIS LICENSE AGREEMENT BEFORE OPENING THE SEALED DISK PACKAGE. 
THIS AGREEMENT IS A LEGAL CONTRACT BETWEEN YOU, THE END USER, AND CARE-
FREE SOFTWARE GOVERNING YOUR USE OF THE SOFTWARE.  OPENING THE SEALED
DISK PACKAGE INDICATES YOUR ACCEPTANCE OF THIS AGREEMENT.  THIS
AGREEMENT SHALL ALSO BE BINDING ON ANY SUBSEQUENT, AUTHORIZED LICENSEE. 
IF YOU DO NOT WISH TO AGREE TO THE TERMS OF THIS AGREEMENT, PROMPTLY
RETURN THE COMPLETE SOFTWARE PROGRAM PACKAGE, WITH THE DISK
PACKAGE(S) UNOPENED, TO CARE-FREE SOFTWARE WITHIN 90-DAYS TO RECEIVE A
FULL REFUND.  IF YOU HAVE ANY QUESTIONS CONCERNING THIS AGREEMENT,
CONTACT CARE-FREE SOFTWARE, 464 NORTH 750 EAST, LINDON, UT 84042, OR CALL
(801) 785-0464.


                                    LICENSE

1.  CARE-FREE SOFTWARE grants you the right to use one copy of the Software on a single-user
computer, or on a single terminal or workstation of a multi-user computer or local area network.  Each
workstation or terminal on a multi-user computer or local area network must be separately licensed by
CARE-FREE SOFTWARE.  If the software package contains both 3´" and 5¨" diskettes, you are
licensed to use only a single set of diskettes for your single user computer, terminal or workstation; you
are not licensed to use the other set of diskettes.

2.  You may not sublicense, rent or lease the Software, but you may permanently transfer your license to
use the Software and accompanying materials by delivering to another party the original diskettes and
material comprising the software package, including this numbered individual license, and by
simultaneously destroying all copies of the Software and accompanying materials in your possession. 
Such transfer terminates your license to use the Software.  The new recipient of the Software and
accompanying materials accepts this agreement and is licensed under the terms of this Agreement upon
initially using the Software.

3.  The Software includes several text files, over a hundred C source code files, and their accompanying
input and output files.  It is intended that those using the Software modify the C source code as part of
the learning process for numerical methods and analysis.  Copies of this Software or self-modified
versions of the source code are not to be distributed for direct commercial advantage without prior
written consent from Harold A. Toomey through CARE-FREE SOFTWARE.

4.  CARE-FREE SOFTWARE further grants you the right to make a backup/archival copy of the
software diskettes as set forth in the Notification of Copyright, above.  You may not copy, transfer, or
otherwise use the Software except as stated in this agreement.


                LIMITED 90-DAY WARRANTY/LIMITATION OF REMEDIES

CARE-FREE SOFTWARE will replace, at no charge, defective diskettes that are returned within 90
days of the original date of purchase.  CARE-FREE SOFTWARE warrants that the diskettes are free
from defects in material and workmanship under normal use and service for a period of ninety (90) days
after receipt.  Any implied warranty(ies) on the diskettes is also limited to ninety (90) days.  By opening
the sealed disk package, you agree that the only remedy available to you will be a refund of the purchase
price of this software program package.  Some states do not allow limitations on duration of an implied
warranty, so the above limitation may not apply to you.

SUCH WARRANTIES ARE IN LIEU OF OTHER WARRANTIES IMPLIED, INCLUDING, BUT
NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE WITH RESPECT TO THE SOFTWARE AND THE
ACCOMPANYING WRITTEN MATERIALS.  IN NO EVENT WILL CARE-FREE SOFTWARE BE
LIABLE TO YOU FOR DAMAGES, INCLUDING ANY LOSS OF PROFITS, LOST SAVINGS, OR
OTHER INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF YOUR USE OF
OR INABILITY TO USE THE PROGRAM, EVEN IF CARE-FREE SOFTWARE OR AN
AUTHORIZED CARE-FREE SOFTWARE REPRESENTATIVE HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  CARE-FREE SOFTWARE WILL NOT BE LIABLE FOR
ANY SUCH CLAIM BY ANY OTHER PARTY.

This limited warranty gives you specific legal rights.  Some states provide other rights, and some states do
not allow excluding or limiting implied warranties or limiting liability for incidental or consequential
damages.  As a result, the above limitations and/or exclusions may not apply to you.  Furthermore, some
jurisdictions have statutory consumer provisions which may supersede this section of the Agreement.

                                    GENERAL

If any provision in this agreement shall be unlawful, void, or for any reason unenforceable, then that
provision shall be deemed severable from this agreement and shall not affect the validity and
enforceability of the remaining provisions of this Agreement.  This Agreement is governed by the laws of
the State of Utah.
 

                 CARE-FREE SOFTWARE'S UNCONDITIONAL GUARANTEE

Your satisfaction is unconditionally guaranteed or your money back.  If for any reason whatsoever, you
are not satisfied with any product purchased from us, we want you to return it to us within 90 days.  We
will be glad to exchange the product or give your money back.

                                                                    NAA42-9/91


10.2  University/Corporation Site License Sample

                     "NUMERICAL ANALYSIS ALGORITHMS IN C"

                 UNIVERSITY/CORPORATION SITE LICENSE (SAMPLE)

This Site License is issued to <UNIVERSITY/CORPORATION NAME HERE>, on <DATE>, by
CARE-FREE SOFTWARE under permission of Harold A. Toomey, the proprietary owner.

Software Version:  4.2
License Number:   <YMMDDX-S>  


                           NOTIFICATION OF COPYRIGHT

THIS SOFTWARE PROGRAM PACKAGE ("SOFTWARE") IS A PROPRIETARY PRODUCT OF
HAROLD A. TOOMEY AND IS BEING DISTRIBUTED BY CARE-FREE SOFTWARE.  AS
SUCH, IT IS PROTECTED BY COPYRIGHT LAWS AND INTERNATIONAL TREATY.  YOU
("UNIVERSITY/CORPORATION") MUST TREAT THE SOFTWARE LIKE ANY OTHER
COPYRIGHTED MATERIAL, EXCEPT THAT YOU MAY MAKE AS MANY COPIES OF THE
SOFTWARE AS NEEDED FOR YOUR UNIVERSITY'S/CORPORATION'S INTERNAL USE
ONLY.  THE SCOPE OF YOUR DISTRIBUTION RIGHTS ARE LISTED BELOW.  COPYRIGHT
LAWS PROHIBIT MAKING ADDITIONAL COPIES OF THE SOFTWARE FOR ANY OTHER
REASON.
 

                        SOFTWARE SITE LICENSE AGREEMENT

READ THIS LICENSE AGREEMENT BEFORE OPENING THE SEALED DISK PACKAGE. 
THIS AGREEMENT IS A LEGAL CONTRACT BETWEEN YOU, THE
UNIVERSITY/CORPORATION, AND CARE-FREE SOFTWARE GOVERNING YOUR USE OF
THE SOFTWARE.  OPENING THE SEALED DISK PACKAGE INDICATES YOUR
ACCEPTANCE OF THIS AGREEMENT.  THIS AGREEMENT SHALL ALSO BE BINDING ON
ANY SUBSEQUENT, AUTHORIZED LICENSEE.  IF YOU DO NOT WISH TO AGREE TO THE
TERMS OF THIS AGREEMENT, PROMPTLY RETURN THE COMPLETE SOFTWARE
PROGRAM PACKAGE, WITH THE DISK PACKAGE(S) UNOPENED, TO CARE-FREE
SOFTWARE WITHIN 90-DAYS TO RECEIVE A FULL REFUND.  IF YOU HAVE ANY
QUESTIONS CONCERNING THIS AGREEMENT, CONTACT CARE-FREE SOFTWARE, 464 NORTH
750 EAST, LINDON, UT  84042, OR CALL (801) 785-0464.


                                    LICENSE

1.  CARE-FREE SOFTWARE grants you the right to make unlimited copies of the Software on your
university/corporation owned single-user computers, terminals and workstations of multi-user computers
and on local area networks.  Each workstation or terminal on a multi-user computer or local area
network need not be separately licensed by CARE-FREE SOFTWARE, so long as they are owned by
you, the university/corporation.  You are licensed to use all sets of diskettes which are shipped with the
Software.

2.  In addition, CARE-FREE SOFTWARE grants your currently enrolled students, employees, and
faculty the right to copy the Software and accompanying manuals for their use, such as for graduate
research and for numerical methods courses.  These individual copies remain part of this site license and
do not belong to the students, employees, or faculty.  For individuals to retain a legal licensed copy of
the Software after they are no longer enrolled or employed or teach at the university/corporation, they
must purchase an Individual License.

3.  You may not sublicense, rent or lease the Software, but you may permanently transfer your license to
use the Software and accompanying materials by delivering to another university/corporation the original
diskettes and material comprising the software package, including this numbered site license, and by
simultaneously destroying all copies of the Software and accompanying materials in your possession. 
Such transfer terminates your license to use the Software.  The new recipient of the Software and
accompanying materials accepts this agreement and is licensed under the terms of this Agreement upon
initially using the Software.

4.  The Software includes several text files, over a hundred C source code files, and their accompanying
input and output files.  It is intended that those using the Software modify the C source code as part of
the learning process for numerical methods and analysis.  Copies of this Software or self-modified
versions of the source code are not to be distributed for direct commercial advantage without prior
written consent from Harold A. Toomey through CARE-FREE SOFTWARE.

5.  CARE-FREE SOFTWARE further grants you the right to make a backup/archival copy of the
software diskettes as set forth in the Notification of Copyright, above.  You may not copy, transfer, or
otherwise use the Software except as stated in this agreement.


                LIMITED 90-DAY WARRANTY/LIMITATION OF REMEDIES

CARE-FREE SOFTWARE will replace, at no charge, defective diskettes that are returned within 90
days of the original date of purchase.  CARE-FREE SOFTWARE warrants that the diskettes are free
from defects in material and workmanship under normal use and service for a period of ninety (90) days
after receipt.  Any implied warranty(ies) on the diskettes is also limited to ninety (90) days.  By opening
the sealed disk package, you agree that the only remedy available to you will be a refund of the purchase
price of this software program package.  Some states do not allow limitations on duration of an implied
warranty, so the above limitation may not apply to you.

SUCH WARRANTIES ARE IN LIEU OF OTHER WARRANTIES IMPLIED, INCLUDING, BUT
NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE WITH RESPECT TO THE SOFTWARE AND THE
ACCOMPANYING WRITTEN MATERIALS.  IN NO EVENT WILL CARE-FREE SOFTWARE BE
LIABLE TO YOU FOR DAMAGES, INCLUDING ANY LOSS OF PROFITS, LOST SAVINGS, OR
OTHER INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF YOUR USE OF
OR INABILITY TO USE THE PROGRAM, EVEN IF CARE-FREE SOFTWARE OR AN
AUTHORIZED CARE-FREE SOFTWARE REPRESENTATIVE HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  CARE-FREE SOFTWARE WILL NOT BE LIABLE FOR
ANY SUCH CLAIM BY ANY OTHER PARTY.

This limited warranty gives you specific legal rights.  Some states provide other rights, and some states do
not allow excluding or limiting implied warranties or limiting liability for incidental or consequential
damages.  As a result, the above limitations and/or exclusions may not apply to you.  Furthermore, some
jurisdictions have statutory consumer provisions which may supersede this section of the Agreement.


                                    GENERAL

If any provision in this agreement shall be unlawful, void, or for any reason unenforceable, then that
provision shall be deemed severable from this agreement and shall not affect the validity and
enforceability of the remaining provisions of this Agreement.  This Agreement is governed by the laws of
the State of Utah.
 

                 CARE-FREE SOFTWARE'S UNCONDITIONAL GUARANTEE

Your satisfaction is unconditionally guaranteed or your money back.  If for any reason whatsoever, you
are not satisfied with any product purchased from us, we want you to return it to us within 90 days.  We
will be glad to exchange the product or give your money back.

                                                                    NAA42-9/91


11.    Packaging Information


To offer the most flexibility to the users, "Numerical Analysis Algorithms in C" v4.2 is shipped on a
variety of floppy diskette sizes and capacities.  Too many files are included in this package to fit them on
a single diskette.  See the appropriate list below to determine how the files are placed on the different
diskettes.

Diskettes are currently available only for IBM PCs and Macintosh computers.  Each shipment comes
with the following:

     - Set of Diskettes with Labels
     - Personalized License Agreement with a unique ID Number
     - Free Technical Support

The below items are available for an additional fee:

     - User's Manual
     - Examples Book
     - MS-DOS Executables
     - Macintosh Executables

The "*.C" source code support files listed below include the following files:

         complex.c         naautil.c        round.c
         eqeval.c          naautil2.c       trunc.c
         gaussj.c          naautil3.c

These files need to be present on each diskette you intend to run the algorithms from.


11.1  MS-DOS Diskettes


11.1.1 5¨" 1.2M High Density Diskettes

Disk #1:   "Readme.doc" Essential Information Document
           "*.C" Source Code Support Files
           Algorithm Source Code for Ch. 1-12
           "IN" Sub-Directory Input Data Files
           "OUT" Sub-Directory Output Data Files
           "UTIL" Sub-Directory Utility Files
           "LANGS" Sub-Directory Multiple Language Examples
           "Revhist.doc" Revision History Document

Disk #2:   "Usersman.doc" User's Manual in ASCII Text


11.1.2 5¨" 360K Low Density Diskettes

Disk #1:   "Readme.doc" Essential Information Document
           "*.C" Source Code Support Files
           Algorithm Source Code for Ch. 1-4

Disk #2:   Algorithm Source Code for Ch. 5-9

Disk #3:   Algorithm Source Code for Ch. 10-12

Disk #4:   "IN" Sub-Directory Input Data Files
           "OUT" Sub-Directory Output Data Files
           "UTIL" Sub-Directory Utility Files
           "LANGS" Sub-Directory Multiple Language Examples
           "Revhist.doc" Revision History Document

Disk #5:   "Usersman.doc" User's Manual in ASCII Text


11.1.3 3´" 1.44M High Density Diskettes

Disk #1:   "Readme.doc" Essential Information Document
           "*.C" Source Code Support Files
           Algorithm Source Code for Ch. 1-12
           "IN" Sub-Directory Input Data Files
           "OUT" Sub-Directory Output Data Files
           "UTIL" Sub-Directory Utility Files
           "LANGS" Sub-Directory Multiple Language Examples
           "Revhist.doc" Revision History Document

Disk #2:   "Usersman.doc" User's Manual in ASCII Text


11.1.4 3´" 720K Low Density Diskettes

Disk #1:   "Readme.doc" Essential Information Document
           "*.C" Source Code Support Files
           Algorithm Source Code for Ch. 1-9

Disk #2:   Algorithm Source Code for Ch. 10-12
           "IN" Sub-Directory Input Data Files
           "OUT" Sub-Directory Output Data Files
           "UTIL" Sub-Directory Utility Files
           "LANGS" Sub-Directory Multiple Language Examples
           "Revhist.doc" Revision History Document

Disk #3:   "Usersman.doc" User's Manual in ASCII Text


11.2  Macintosh Diskettes


11.2.1 3´" 800K Macintosh Diskettes

Disk #1:   "Readme.doc" Essential Information Document
           "*.C" Source Code Support Files
           Algorithm Source Code for Ch. 1-11

Disk #2:   Algorithm Source Code for Ch. 11-12
           "IN" Sub-Directory Input Data Files
           "OUT" Sub-Directory Output Data Files
           "UTIL" Sub-Directory Utility Files
           "LANGS" Sub-Directory Multiple Language Examples
           "Revhist.doc" Revision History Document
           "Usersman.doc" User's Manual in ASCII Text


12.    Purchasing Information


There are two ways to legally purchase and use this software.  The first is by ordering it directly from
Care-Free Software.  The second is by copying it from a licensed user and mailing a $20.00 check for an
individual license.  Both methods provide you with the same product, assuming you do not copy an old
version of the software.

"Numerical Analysis Algorithms in C" is written to be used by colleges, universities, and students. 
Knowing that the budgets of all three are usually very limited, the prices are kept low enough to have
this software accessible by everyone.  It is not unusual for student to want these algorithms for use in
their profession after graduation.


12.1  $20.00 Club

The $20.00 Club is really quite simple.  To join, just copy this software from someone else and send
Care-Free Software a check for $20.00.  This offer only applies for individual licenses, not for site
licenses.  In exchange, Care-Free Software will send you an individual license, some diskette labels, and
keep you informed of enhancements and upcoming releases.  The User's Manual and Examples Book are
not included, but can be purchased separately.

If you are a student attending a school which has not yet purchased a site license, you should pay for
these programs.  The $20.00 Club is our way of allowing students to take a class requiring these
algorithms and be able to quickly and easily have this software available to them.  The main difference is
that you make your own diskettes and save a few dollars doing so.  This method is commonly referred to
as Shareware.

If you are a student currently enrolled at a college or university which has purchased a university site
license, you may copy and use this software from the university computers for free.  If you intend to use
the programs on your job after graduating, then you should purchase an individual license.  See the
sample university/corporation site license in Chapter 10 - "Sample License Agreements" of this manual.


12.2  Order Form

An order form is provided for your convenience.  Use it to ensure you have the most recent version of
this software.
                                 ORDER FORM

                     "NUMERICAL ANALYSIS ALGORITHMS IN C"

A complete set of 116 stand-alone C programs have been written for the text Numerical Analysis,
Burden & Faires, 3rd and 4th edition.  These programs include ALL of the algorithms as well as all
modifications required for most of the homework exercises.  The C source code is thoroughly
commented and easily modified.  The same source code runs on MS-DOS, UNIX, VMS, the Macintosh,
and more!

                   For a FREE demo disk call 1-801-785-0464.

           TO ORDER CALL OR MAIL THIS FORM TO:
                      CARE-FREE SOFTWARE
                      C/O HAROLD A. TOOMEY
                      464 NORTH 750 EAST
                      LINDON, UT  84042

Please Indicate Method of Payment:
Check _____  Purchase Order _____ C.O.D. _____
Name ______________________________________________________________
Address ___________________________________________________________
        ___________________________________________________________
Phone______________________________________________________________

Please Send Me:
Individual Licenses:
_____  Version 4.2 on MS-DOS Disks          $30.00
_____  Version 4.2 on Macintosh Disks       $35.00
_____  Demo Disk: MAC _____  DOS _____      FREE 
_____  User's Manual (170 pages)            $20.00
_____  Examples Book (670 pages)            $65.00

Site Licenses:
_____  University/Corporation Packet        $800.00
     (Includes: Set of MS-DOS and Macintosh disks, a User's Manual, Examples Book, and a site
     license good for unlimited campus/corporate use.)

Diskette Size:
_____ 5¨" (360K) _____ 3´" (720K)_____ 3´" (800K Macintosh)
_____ 5¨" (1.2M) _____ 3´" (1.44M)

_______________  MERCHANDISE TOTAL  (prices include S&H)
_______________  C.O.D. Orders add $5.00
_______________  UTAH RESIDENTS add 6¨% Sales Tax
_______________  TOTAL
                 UNLIMITED CUSTOMER SUPPORT!  1-801-785-0464.        (7/7/93)References


Balfour, Alexander, "Programming in Standard Fortran 77", North Holland, 1979.

Borenstein, Philip, "THINK C User's Manual", Symantec Corporation, 1989.

Bourne, Philip E., "UNIX for VMS Users", Digital Press, 1990.

Burden, Richard L., "Numerical Analysis", third edition, PWS-Kent Publishing Company, 1985.

Burden, Richard L., "Numerical Analysis", fourth edition, PWS-Kent Publishing Company, 1989.

Jaeschke, Rex, "Portability and the C Language", Hayden Books, 1988.

Kernighan, Brian W., "The C Programming Language", first edition, Prentice Hall Software Series, 1984.

Kernighan, Brian W., "The C Programming Language", second edition, Prentice Hall Software Series,
1988.

Koffman, Eliot B., "Pascal, A Problem Solving Approach", Addison-Wesley Publishing Company, 1982.

Mattson, Jeff, "THINK C, The Professional's Choice, Standard Libraries Reference", Symantec
Corporation, 1989.

"Microsoft C 5.0 Optimizing Compiler, Language Reference, Microsoft CodeView, and Utilities",
Microsoft Corporation, 1987.

"Microsoft C 5.0 Optimizing Compiler, Run-Time Library Reference", Microsoft Corporation, 1987.

"Microsoft C 5.0 Optimizing Compiler, User's Guide and Mixed-Language Programming Guide",
Microsoft Corporation, 1987.

"Reference Manual for the Ada Programming Language, ANSI/MIL-STD-1815A-1983", Meridian
Software Systems, February 17, 1983.

Sideris, Daniel A., "VAX/VMS: Mastering DCL Commands and Utilities", QED Information Sciences,
Inc., 1990.

Tucker, Allen B., "Apple Pascal, A Programming Guide", CBS College Publishing, 1982.

"Turbo Pascal, Version 3.0, Reference Manual", Borland International, 1985.
Appendix A:       C Source Code for 041.C


/******************************************************************************
                  Composite Simpson's Rule - Algorithm 4.1
*******************************************************************************

                                Ùb
To approximate the integral I = ≥  f(x) dx:
                                ıa

INPUT endpoints a, b; even positive integer n; the function f().

OUTPUT approximation XI to I.

NOTE: Listed as Simpson's Composite Rule in 3rd edition of the text.

*******************************************************************************
*        Written by:  Harold A. Toomey, CARE-FREE SOFTWARE, 3Q 1991, v4.2      *
******************************************************************************/

/*
**  Set the EQ_EVAL flag to TRUE in "naautil.c" to use the Equation Evaluator.
*/

#include "naautil.c"               /* Numerical Analysis Algorithms Utilities. */

char *outfile   = "041.out";       /* Default name of the output file.         */
char *eq_text_f = "f(x) = sin(x)";          /* Needs updating  $        */


/*****************************************************************************/
/* f(x) - Function to evaluate, f(x).  Needs updating $.                     */
/*****************************************************************************/
double f(x)
double x;
{
  if (eqeval)
    return (eval_eq(x));           /* Use the Equation Evaluator  */
  else
    return (sin(x));               /* Use the default function.   */
}
/*****************************************************************************/


main()
{
  double a, b, h, X, XI, XI0, XI1, XI2, f();
  int i, n;

  /**********
   * INPUTS *
   **********/

  NAA_do_first(outfile);           /* NAA initialization procedure. */

  printf2("Composite Simpson's Rule - Algorithm 4.1\n\n");

  if (eqeval)
    printf2("f(x) = %s", tmpstr);           /* Print the Equation Evaluator text */
  else
    printf2("%s", eq_text_f);               /* Print the default equation text */
  printf("\n\n");

  printf("Enter endpoint a: ");
  scanf("%lf", &a);
  printf("Enter endpoint b: ");
  scanf("%lf", &b);
  fprintf(file_id, " from %lg to %lg.\n\n", a, b);

  do {
    printf("Enter even number of intervals on [a,b], n: ");
    scanf("%d", &n);
    if ((n <= 0) || (n % 2 != 0))
      printf("ERROR - n must be even and positive.\n");
  } while ((n <= 0) || (n % 2 != 0));
  fprintf(file_id, "n = %d intervals on [a,b].\n", n);

  /*************
   * ALGORITHM *
   *************/

  /* STEP #1 */
  h = (b - a)/n;

  /* STEP #2 */
  XI0 = f(a) + f(b);
  XI1 = 0.0;                       /* Summation of f(x(2i-1)). */
  XI2 = 0.0;                       /* Summation of f(x(2i)).   */

  /* STEP #3 */
  for (i=1;i<n;i++) {

    /* STEP #4 */
    X = a + i*h;

    /* STEP #5 */
    if (i % 2 == 0)
      XI2 += f(X);                 /* For even i. */
    else
      XI1 += f(X);                 /* For odd i.  */
  }

  /* STEP #6 */
  XI = h*(XI0 + 2.0*XI2 + 4.0*XI1) / 3.0;

  /***********
   * OUTPUTS *
   ***********/

  /* STEP #7 */
  printf2("Interval number h = %lg\n\n", h);
  printf2("     Ù%lg\n", b);
  printf2("XI = ≥  f(x) dx = %.11lg\n", XI);
  printf2("     ı%lg\n\n", a);
  printf2("Required %d functional evaluations.\n", n+1);

  NAA_do_last(outfile);            /* NAA finish-up procedure. */

}                                  /* STOP */

/*****************************************************************************/
/*       Copyright (C) 1988-1991, Harold A. Toomey, All Rights Reserved.      */
/*****************************************************************************/Appendix B:C Source Code for NAAUTIL.C


/******************************** NAAUTIL.C ***********************************
              "Numerical Analysis Algorithms in C" Utilities I v4.2
******************************************************************************/

/*
**  This source file contains many useful procedures, some being used in all
**  of the "Numerical Analysis Algorithms in C" programs.
**
**  At least three of the #defines are needed for all of the supporting ".c"
**  programs.  These #defines are: TRUE, FALSE, and ANSI.  The supporting
**  ".c" files are:
**
**       naautil.c         complex.c        round.c
**       naautil2.c        eqeval.c         trunc.c
**       naautil3.c        gaussj.c
**
**  Many of these functions where derived from the book "Numerical Recipes
**  in C".
**
**  "Naautil.c" contains the most often used routines.  Most are dynamic
**  memory allocation routines used to create very flexible vectors and
**  matrices.
**
**  "Naautil2.c" contains less frequently used dynamic memory allocation
**  routines to create very flexible vectors, matrices, and cubes.
**  Currently used only by: "081.c" and "125.c"
**
**  "Naautil3.c" contains routines for complex vectors, matrices, and cubes.
**  Currently used only by: "027.c", "028a.c" and "081.c"
**
**  This file should be included (only once!) whenever the following
**  procedures or functions are used:
**
**    Return    Procedure
**    Type      Name             Description
**    ----------------------------------------------------------------------
**    void      naaerror      -  Numerical Analysis Algorithms Error Handler
**    int       printf2       -  Like printf() but writes to a file too
**    void      NAA_do_first  -  NAA initialization procedure
**    void      NAA_do_last   -  NAA final procedure
**
**    int*           ivector  -  Allocates a 1-D array of integers
**    float*         vector   -  Allocates a 1-D array of floats
**    double*        dvector  -  Allocates a 1-D array of doubles
**    long double*   ldvector -  Allocates a 1-D array of long doubles
**    fcomplex*      cvector  -  Allocates a 1-D array of fcomplex
**
**    int**          imatrix  -  Allocates a 2-D array of integers
**    float**        matrix   -  Allocates a 2-D array of floats
**    double**       dmatrix  -  Allocates a 2-D array of doubles
**    long double**  ldmatrix -  Allocates a 2-D array of long doubles
**    fcomplex**     cmatrix  -  Allocates a 2-D array of fcomplex
**
**    int***         icube    -  Allocates a 3-D array of integers
**    float***       cube     -  Allocates a 3-D array of floats
**    double***      dcube    -  Allocates a 3-D array of doubles
**    long double*** ldcube   -  Allocates a 3-D array of long doubles
**    fcomplex***    ccube    -  Allocates a 3-D array of fcomplex
**
**    void      free_ivector  -  Frees the allocated 1-D array memory
**    void      free_vector   -  Frees the allocated 1-D array memory
**    void      free_dvector  -  Frees the allocated 1-D array memory
**    void      free_ldvector -  Frees the allocated 1-D array memory
**    void      free_cvector  -  Frees the allocated 1-D array memory
**
**    void      free_imatrix  -  Frees the allocated 2-D array memory
**    void      free_matrix   -  Frees the allocated 2-D array memory
**    void      free_dmatrix  -  Frees the allocated 2-D array memory
**    void      free_ldmatrix -  Frees the allocated 2-D array memory
**    void      free_cmatrix  -  Frees the allocated 2-D array memory
**
**    void      free_icube    -  Frees the allocated 3-D array memory
**    void      free_cube     -  Frees the allocated 3-D array memory
**    void      free_dcube    -  Frees the allocated 3-D array memory
**    void      free_ldcube   -  Frees the allocated 3-D array memory
**    void      free_ccube    -  Frees the allocated 3-D array memory
*/

/*********************/
/* DEFINES AND FLAGS */
/*********************/

/*
**  The FLAGS below allow the users more flexibility when compiling and
**  running these Numerical Analysis Algorithms.  They can also be used to
**  make these programs more portable to different computer systems.
*/

#define  PI       3.14159265358979323846264338327950288419716939937510582097

#ifndef FALSE
#define FALSE              0       /* Define FALSE if not already defined.      */
#endif

#ifndef TRUE
#define TRUE               !FALSE  /* Define TRUE if not already defined.       */
#endif

#define  ANSI              TRUE    /* Set to TRUE if using an ANSI C standard   */
                                   /* compliant compiler (default).             */
                                   /* Set to FALSE if using an older C compiler */
                                   /* (Kernighan & Ritchie Style C).            */

#define  ANSI_FUNCT        FALSE   /* Set to TRUE if using ANSI's style for     */
                                   /* declaring functions.  Set to FALSE if     */
                                   /* using K&R style functions (default).      */
                                   /* (Set to TRUE if using THINK C 4.0 on a    */
                                   /* Macintosh.)                               */

#define TITLE_PROMPT       TRUE    /* Set to TRUE if you want to be prompted    */
                                   /* for an optional title at the start of     */
                                   /* each program (default).                   */
                                   /* Set to FALSE to disable the title prompt. */

#define  FILE_SAVE         TRUE    /* Set to TRUE to save output to a file      */
                                   /* (default).                                */
                                   /* Set to FALSE to create no output file.    */

#define EQ_EVAL            FALSE   /* Set to TRUE to be prompted for the use of */
                                   /* the Equation Evaluator at run-time.       */
                                   /* Set to FALSE if entering f(x) inside the  */
                                   /* C source code and re-compiling it.        */
                                   /* (default)                                 */

#define  NAAUTIL_OBJ       FALSE   /* Set to TRUE if using "naautil.c" as a     */
                                   /* pre-compiled object code file to be       */
                                   /* linked to at algorithm compile time.      */
                                   /* Set to FALSE if using "naautil.c" as an   */
                                   /* un-compiled include file (default).       */

/********************** Computer System Specific Flags ***********************/

#define  OLD_UNIX_OS       FALSE   /* TRUE if running on older UNIX systems.    */

#define NO_LONG_DOUBLES    FALSE   /* TRUE if your C compiler does not have     */
                                   /* the "long double" type.                   */
                                   /* (Set to TRUE for most VAX C compilers)    */

/*****************************************************************************/

#define  MAX_LINE_SIZE 130         /* Largest input line size accepted.      */
                                   /* Set to 130 for MS-DOS computers.       */


/*****************
 * INCLUDE FILES *
 *****************/

#include <math.h>                  /* For math function prototypes.             */
#include <stdio.h>                 /* For scanf(), printf() and fprintf().      */
#include <stdlib.h>                /* Needed for calloc(), free() and rand().   */

#if OLD_UNIX_OS == TRUE            /* For older UNIX C compilers       */
#include <varargs.h>               /* For vfprintf() used in printf2() */
#else
#include <stdarg.h>                /* For vfprintf() used in printf2() */
#endif

/*
**  NOTE: Including <ctype.h> for tolower() may causes errors in Microsoft C
**  5.0 for IBM PCs where tolower() is defined in the <stdlib.h> header file
**  as well.
*/


/********************
 * GLOBAL VARIABLES *
 ********************/

#if NAAUTIL_OBJ == FALSE           /* If "naautil.c" is not pre-compiled.    */
  FILE *file_id;                   /*   Identifies the output file.          */
  char  tmpstr[MAX_LINE_SIZE];     /*   A temporary string.                  */
  int   eqeval = FALSE;            /*   Set if using the Equation Evaluator. */
#else                              /* If "naautil.c" is pre-compiled.        */
  extern FILE *file_id;
  extern char  tmpstr[MAX_LINE_SIZE];
  extern int   eqeval;
#endif


/***********************
 * FUNCTION PROTOTYPES *
 ***********************/

#if ANSI == TRUE           /* ANSI STANDARD PROTOTYPING (Post-December 14, 1989)*/
  void           naaerror      (char error_text[]);
  int            printf2       (char *format, ...);
  void           NAA_do_first  (char *outfile);
  void           NAA_do_last   (char *outfile);
  double**       dmatrix       (int a, int b, int c, int d);
  float**        matrix        (int a, int b, int c, int d);
  double*        dvector       (int a, int b);
  float*         vector        (int a, int b);
  int*           ivector       (int a, int b);
  void           free_dmatrix  (double **m, int a, int b, int c, int d);
  void           free_matrix   (float **m, int a, int b, int c, int d);
  void           free_dvector  (double *v, int a, int b);
  void           free_vector   (float *v, int a, int b);
  void           free_ivector  (int *v, int a, int b);
  double         eval_eq       (double x, ...);
#else  /* ANSI */          /* OLDER STYLE PROTOTYPING (Pre-December 14, 1989) */
                           /* For compatibility with older C compilers.       */
  void           naaerror();
  int            printf2();
  void           NAA_do_first();
  void           NAA_do_last();
  double**       dmatrix();
  float**        matrix();
  double*        dvector();
  float*         vector();
  int*           ivector();
  void           free_dmatrix();
  void           free_matrix();
  void           free_dvector();
  void           free_vector();
  void           free_ivector();
  double         eval_eq();
#endif   /* ANSI */


#if NAAUTIL_OBJ == FALSE           /* Include the routines below only if the */
                                   /* NAAUTIL_OBJ flag is set to FALSE.      */

/****************************
 * EQUATION EVALUATOR LOGIC *
 ****************************/

#if EQ_EVAL == TRUE                /* Needed for the Equation Evaluator's     */
#include "eqeval.c"                /* defines, global variables and functions */
#else  /* EQ_EVAL */

#if ANSI == TRUE
double eval_eq (double x, ...)     /* May need this "dummy" procedure */
{
  return 0.0;
}
#else
double eval_eq (x, ...)            /* May need this "dummy" procedure */
double x;
{
  return 0.0;
}
#endif  /* ANSI */

#endif  /* EQ_EVAL */


/***************
 * SUBROUTINES *
 ***************/

/*****************************************************************************/
/* naaerror() - Numerical Analysis Algorithms standard error handler.        */
/*****************************************************************************/
void naaerror(error_text)
char error_text[];
{
  /* Print error message to the screen.  (Standard error device) */
  fprintf(stderr, "\n\"Numerical Analysis Algorithms in C\" run-time");
  fprintf(stderr, " error...\n%s\n", error_text);
  fprintf(stderr, "...now exiting to system...\n");
  exit(-1);                        /* Exit the program. */
}


#if FILE_SAVE == FALSE

/*****************************************************************************/
/* Since variable arguments are so terribly non-portable, the below two      */
/* defines will allow the programs to work properly, but without the use of  */
/* the file_save option (or variable argument lists).  They turn printf2()   */
/* into tried-and-true printf() and they hide the usage of the file_id       */
/* variable by turning "fprintf(file_id, ...)" into "sprintf(tmpstr, ...)".  */
/* This causes a write to an ignored string instead of to a file.            */
/*****************************************************************************/

#define printf2            printf           /* For printf2() */
#define fprintf            sprintf          /* For fprintf(file_id, ...) */
#define file_id            tmpstr

#else    /* FILE_SAVE == TRUE */

#if OLD_UNIX_OS == TRUE                     /* For older UNIX C compilers */

/*****************************************************************************/
/* printf2() - Like printf() but prints to the outfile (file_id) also, if    */
/*             the FILE_SAVE flag is set to TRUE.                            */
/*             Use this printf2() instead of the below printf2() if your C   */
/*             compiler does not have <stdarg.h>, but does have <varargs.h>. */
/*                                                                           */
/*             NOTE:  This code segment has not been tested.                 */
/*****************************************************************************/

/*
**  printf2() - OPTION #1 -- Uses #include <varargs.h>
*/

int printf2(va_alist)
va_list va_alist;
/* or   (w/out a ';')
va_decl
*/
{
  va_list args;
  char *format;
  int length;

  /* Note the one less parameter in va_start() than in the below printf2() */
  va_start(args);
  format = va_arg(args, char*);
  length = vprintf(format, args);
  vfprintf(file_id, format, args);
  va_end(args);
  return length;
}

#else  /* OLD_UNIX_OS */                    /* For ANSI C compilers */

/*****************************************************************************/
/* printf2() - Like printf() but prints to the outfile (file_id) also, if    */
/*             the FILE_SAVE flag is set to TRUE.                            */
/*****************************************************************************/

/*
**  printf2() - OPTION #2 -- Uses #include <stdarg.h>
*/

#if ANSI_FUNCT == TRUE
int printf2(char *format, ...)
#else
int printf2(format, ...)
char *format;
#endif
{
  va_list args;
  int length;

  va_start(args, format);
  length = vprintf(format, args);           /* Prints to the screen (stdout).  */
  vfprintf(file_id, format, args);          /* Prints to a file (file_id).     */
  va_end(args);
  return length;
}

#endif   /* OLD_UNIX_OS */

#endif   /* FILE_SAVE */


/*****************************************************************************/
/* NAA_do_first() - Opens the output file if the FILE_SAVE flag is set to    */
/*                  TRUE, prints the NAA banner to the screen and output     */
/*                  file, then prompts for an optional title and the         */
/*                  optional Equation Evaluator.                             */
/*****************************************************************************/
void NAA_do_first(outfile)
char *outfile;
{
  int i;

#if FILE_SAVE == TRUE              /* Set to TRUE if saving output to a file. */
  /* Open the default output file initialized in the main program. */
  if ((file_id = fopen(outfile, "w")) == NULL) {
    sprintf(tmpstr, "Can not open the output file named \"%s\".", outfile);
    naaerror(tmpstr);
  }
#endif   /* FILE_SAVE */

  /* Print the Numerical Analysis Algorithms banner. */
  for (i=1;i<80;i++)  printf2("-");
  printf2("\n\t\t   \"Numerical Analysis Algorithms in C\" v4.2\n");
  for (i=1;i<80;i++)  printf2("-");
  printf2("\n\n");

#if TITLE_PROMPT == TRUE
  /* Prompt for an optional title to be placed into the output file. */
  printf("Enter an optional title [ie - Set 2.1,  Problem 2 a) ].\n----> ");
  fgets(tmpstr, MAX_LINE_SIZE, stdin);

  /* Print the optional title to the output file only if one was entered. */
  if (tmpstr[0] != '\n')
    fprintf(file_id, "%s\n", tmpstr);
  printf("\n");
#endif   /* TITLE_PROMPT */

#if EQ_EVAL == TRUE
  get_eq();                /* Get the equation and store it into "tmpstr." */
  if (eqeval == TRUE)      /* eqeval is set by get_eq().  If set, then     */
    parse_eq();            /* parse the equation into a usable structure.  */
#endif   /* EQ_EVAL */

}

/*****************************************************************************/
/* NAA_do_last() - Closes the default output file and informs the user of    */
/*                 its creation or update.                                   */
/*****************************************************************************/
void NAA_do_last(outfile)
char *outfile;
{

#if FILE_SAVE == TRUE
  if (fclose(file_id) == EOF) {
    sprintf(tmpstr, "Can not close the output file named \"%s\".", outfile);
    naaerror(tmpstr);
  }
  printf("\nOutput saved into file \"%s\".\n", outfile);
#endif   /* FILE_SAVE */

}

/*****************************************************************************/
/* dmatrix() - Allocates a double matrix with range [a..b][c..d].            */
/*****************************************************************************/
double **dmatrix(a,b,c,d)
int a,b,c,d;
{
  int i;
  double **m;

  /* allocate pointers to rows. */
  m = (double **) calloc((unsigned) (b-a+1), sizeof(double*));
  if (!m)
    naaerror("allocation failure 1 in dmatrix()");
  m -= a;

  /* allocate rows and set pointers to them. */
  for (i=a;i<=b;i++) {
    m[i] = (double *) calloc((unsigned) (d-c+1), sizeof(double));
    if (!m[i])
      naaerror("allocation failure 2 in dmatrix()");
    m[i] -= c;
  }

  return (m);              /* return pointer to array of pointers to rows. */
}

/*****************************************************************************/
/* matrix() - Allocates a float matrix with range [a..b][c..d].              */
/*****************************************************************************/
float **matrix(a,b,c,d)
int a,b,c,d;
{
  int i;
  float **m;

  /* allocate pointers to rows. */
  m = (float **) calloc((unsigned) (b-a+1), sizeof(float*));
  if (!m)
    naaerror("allocation failure 1 in matrix()");
  m -= a;

  /* allocate rows and set pointers to them. */
  for (i=a;i<=b;i++) {
    m[i] = (float *) calloc((unsigned) (d-c+1), sizeof(float));
    if (!m[i])
      naaerror("allocation failure 2 in matrix()");
    m[i] -= c;
  }

  return (m);              /* return pointer to array of pointers to rows. */
}

/*****************************************************************************/
/* dvector() - Allocates a double vector with range [a..b].                  */
/*****************************************************************************/
double *dvector(a,b)
int a,b;
{
  double *v;

  v = (double *) calloc((unsigned) (b-a+1), sizeof(double));
  if (!v)
    naaerror("allocation failure in dvector()");
  return (v-a);
}

/*****************************************************************************/
/* vector() - Allocates a float vector with range [a..b].                    */
/*****************************************************************************/
float *vector(a,b)
int a,b;
{
  float *v;

  v = (float *) calloc((unsigned) (b-a+1), sizeof(float));
  if (!v)
    naaerror("allocation failure in vector()");
  return (v-a);
}

/*****************************************************************************/
/* ivector() - Allocates an integer vector with range [a..b].                */
/*****************************************************************************/
int *ivector(a,b)
int a,b;
{
  int *v;

  v = (int *) calloc((unsigned) (b-a+1), sizeof(int));
  if (!v)
    naaerror("allocation failure in ivector()");
  return (v-a);
}

/*****************************************************************************/
/* free_dmatrix() - Frees a matrix allocated with dmatrix().                 */
/*****************************************************************************/
void free_dmatrix(m,a,b,c,d)
double **m;
int a,b,c,d;                       /* (variable d is never used.) */
{
  int i;

  for(i=b;i>=a;i--)
    free((char *) (m[i]+c));
  free((char *) (m+a));
}

/*****************************************************************************/
/* free_matrix() - Frees a matrix allocated with matrix().                   */
/*****************************************************************************/
void free_matrix(m,a,b,c,d)
float **m;
int a,b,c,d;                       /* (variable d is never used.) */
{
  int i;

  for(i=b;i>=a;i--)
    free((char *) (m[i]+c));
  free((char *) (m+a));
}

/*****************************************************************************/
/* free_dvector() - Frees a double vector allocated by dvector().            */
/*****************************************************************************/
void free_dvector(v,a,b)
double *v;
int a,b;                           /* (variable b is never used.) */
{
  free((char *) (v+a));
}

/*****************************************************************************/
/* free_vector() - Frees a float vector allocated by vector().               */
/*****************************************************************************/
void free_vector(v,a,b)
float *v;
int a,b;                           /* (variable b is never used.) */
{
  free((char *) (v+a));
}

/*****************************************************************************/
/* free_ivector() - Frees an integer vector allocated by ivector().          */
/*****************************************************************************/
void free_ivector(v,a,b)
int *v,a,b;                        /* (variable b is never used.) */
{
  free((char *) (v+a));
}


/*****************************************************************************/

#endif   /* NAAUTIL_OBJ */

/******************************************************************************
*        Written by:  Harold A. Toomey, CARE-FREE SOFTWARE, 3Q 1991, v4.2      *
*        Copyright (C) 1988-1991, Harold A. Toomey, All Rights Reserved.       *
******************************************************************************/Appendix C:       Language Comparison Charts

This section is intended to help those who have learned other
languages other than C to transfer their knowledge easily into C.  The
tables provided should help in understanding and modifying the
equations and code as needed to perform numerical analysis.  These
tables provide a simple comparison of items most likely to be used in
numerical analysis programs.

Complete working example programs are also provided to give clear
examples of how programs look in each of the below languages. 

The languages compared to C include:

LANGUAGE          COMPILER                           STANDARD
-------------------------------------------------------------------
1. Ada            Meridian Ada 4.1                   ANSI/MIL-STD-1815A
2. BASIC          Microsoft GW-BASIC 3.20
3. C              Microsoft C 5.0                    ANSI C
4. C++            Borland Turbo C++ 2.0              AT&T 2.0 C++
5. FORTRAN 77     Microsoft FORTRAN 77 3.3           ANSI FORTRAN 77
6. Pascal         Borland Turbo PASCAL 3.01A

(NOTE: '...' means one or more statements).
C.1      C vs Ada

Description:               C                         ADA
======================================================================

ARITHMETIC OPERATORS:
----------------------------------------------------------------------
Addition                   +                         +
Subtraction                -                         -
Multiplication             *                         *
Division                   /                         /
Modulus (real)             fmod(), modf()            N/A
Modulus (integer)          %                         MOD, REM
Exponentiation             pow()                     **


RELATIONAL OPERATORS:
----------------------------------------------------------------------
Greater Than               >                         >
Greater Then or Equal      >=                        >=
Less Than                  <                         <
Less Than or Equal         <=                        <=
Equal                      ==                        =
Not Equal                  !=                        /=


LOGICAL OPERATORS:                          (With Bit_Ops; Use Bit_Ops;)
----------------------------------------------------------------------
And                        &&                        AND
Or                         ||                        OR
Not                        !                         NOT
Xor                        N/A                       XOR


ASSIGNMENT OPERATORS:
----------------------------------------------------------------------
Assignment                 =                         :=
Assignment w/Add           i += 2;                   I := I + (2);
Assignment w/Sub           i -= 4;                   I := I - (4);
Assignment w/Mult          x *= -2.1;                X := X * (-2.1);
Assignment w/Div           x /= 8.9;                 X := X / (8.9);
Assignment w/Mod           x %= 7.3;                 X := X REM (7.3);


INCREMENT AND DECREMENT STATEMENTS:
----------------------------------------------------------------------
Post-Increment             i++;                      I := I + 1;
Post-Decrement             i--;                      I := I - 1;
Pre-Increment              ++i;                      I := I + 1;
Pre-Decrement              --i;                      I := I - 1;


DATA TYPES:                                 (With Standard; Use Standard;)
----------------------------------------------------------------------
Character                  char                      CHARACTER
String                     char str[n];              str : STRING(1..20)
                                                     -or-  STRING
Integer                    int                       INTEGER
Integer with limits        (use int)                 POSITIVE
                           (use int)                 NATURAL
Long Integer               long                      
Floating Point             float                     FLOAT -or- REAL
Double-Precision Float     double           
Double Double-Precision    long double               
Complex                    fcomplex (naautil.c)      (See the record below)
Arrays                     float A[3][2];            A : ARRAY (1..3,1..2)
                                                       of FLOAT;
Enumeration                enum gender {M,F};        type GENDER is (M,F);
Boolean                                              BOOLEAN
Pointers                   int *ptr;                 PTR = ^INTEGER;  ???
Structures                 struct complex {          type COMPLEX_TYPE is
                             float r, i;               RECORD          
                           };                            R, I : REAL;
                                                       END RECORD;
File Pointers              FILE *fptr;               

         Examples of ADA type declarations:
                  type STRING  is array  (POSITIVE range <>) of
                    CHARACTERS;
                  type INTEGER is range  1..2_000;
                  type FLOAT   is digits 16;
                  type REAL    is digits 16;
                  type REAL    is digits 16  range 0.0..1.0E35;
                  type FIXED   is delta  0.1 range 0.0..255.0;


DATA TYPE INITIALIZATION:                   (With Standard; Use Standard;)
----------------------------------------------------------------------
Character                  char ch = 'c';            CH := 'c';
String                     char *str = "A string";   STR := "A string";
Integer                    int i = 5;                I := 5;
Long Integer               int i = 5L;               
Floating Point             float x = 123.4F;         X := 123.4;
Floating Point             float x = 1.0e-2F;        X := 1.0E-2;
Double-Precision Float     double x = 123.4;                  
Double-Precision Float     double x = 1e-2;                   
Double Double-Precision    long double x = 123.4L;   
Double Double-Precision    long double x = 1e-2L;    
Complex                    fcomplex c = {6.2,7.1};
Arrays                     float A[3][2] = {{4,2},{1,-2},{0,5}};       
                                                     A(2,2) := -2;
Enumeration                boolean ANS = NO;         
Boolean                    N/A                       BOOLEAN FOUND;
                                                     FOUND := FALSE;
Pointers                   char *                    ^
Structures                 struct complex {          RECORD1 := RECORD2;
                             float r = 12.0;                    
                             float i = 7.0;                     
                           };                          
File Pointers              FILE *fptr;               
Constants                  #define PI 3.1415           CONST PI = 3.1415;
                           const char DOLLAR = '$';  CONST DOLLAR = '$';


                                            (With Unchecked_Conversion;)
DATA TYPE CONVERSION:                       (Use  Unchecked_Conversion;)
----------------------------------------------------------------------
Character                  (char) i                  CHARACTER(i);
String                     (char *) x                STRING(x);
Integer                    (int) ch                  INTEGER(ch);
Long Integer               (long) x                  
Floating Point             (float) x                 REAL(x);
Double-Precision Float     (double) x                
Double Double-Precision    (long double) x
Complex                    (complex) x               COMPLEX(x);
Other Types                typedef ... new_type;     type NEW_TYPE is ...;
                           (new_type) x              NEW_TYPE(x);


STANDARD FUNCTIONS:                         (With Math_Lib; Use Math_Lib;)
----------------------------------------------------------------------
Truncation                 trunc() (in trunc.c)      
Round                      round() (in round.c)      
Nearest Integer            ceil()                    
Nearest Whole Number       floor()                   
Absolute Value             abs(), fabs()             ABS()
Odd (INTEGER)              #define ODD(a) (a%2)?(1):(0)

Square Root                sqrt()                    SQRT()
Square                     x*x                       X*X
Exponential                exp()                     EXP()
Natural Log                log()                     LOG(X)
Common Log                 log10()                   LOG(X,10)
Power                      pow(x,y)                  "**"(X,Y)

Sine                       sin()                     SIN()
Cosine                     cos()                     COS()
Tangent                    tan()                     TAN()
Cotangent                  1.0/tan()                 COT()
Arcsine                    asin()                    ARCSIN()
Arccosine                  acos()                    ARCCOS()
Arctangent                 atan()                    ATAN(X)
Atan of Quotient           atan2()                   ATAN(X,Y)

Hyperbolic Sine            sinh()                    SINH()
Hyperbolic Cosine          cosh()                    COSH()
Hyperbolic Tangent         tanh()                    TANH()
Hyperbolic Cotangent       1.0/tanh()                COTH()
Hyperbolic Arcsine                                   ARCSINH()
Hyperbolic Arccosine                                 ARCCOSH()
Hyperbolic Arctangent                                ARCTANH()
Hyperbolic Arccotangent                              ARCCOTH()

Random Number              rand(), srand()           


SYNTAX:
----------------------------------------------------------------------
Case Sensitive?            YES                       NO
Name a program             main()                    Procedure Prog_Name is
                           {                         begin
                             ...                       ...
                           }                         end Prog_Name;
Define a Package           use #include "package_name.h"
                                                     Package Prog_Name is
                                                       ...
                                                     end;
                                                     Package body Prog_Name
                                                     is
                                                       ...
                                                     end Prog_Name;
Comment Begin              /*                        --
Comment End                */                        <CARRIAGE RETURN>
Begin Symbol               {                         BEGIN
End Symbol                 }                         END;  -or-  END function_name;
Statement Terminator       ;                         ; 
Include Files              #include <filename.h>     With Package_name;
                           #include "filename.h"
Variable Names             a-zA-Z0-9_                A-Z0-9_
                           (31 chars max.)           (? chars max.)

Functions                  float func_name (int x, y)
                           {
                             ...
                             return some_float;
                           }
                                FUNCTION FNAME (X,Y: REAL) RETURN REAL is
                                  ...
                                  RETURN SOMEREAL;
                                end FNAME;

Procedures                 proc_name (int x, y)
                                          PROCEDURE PROC_NAME(X,Y: REAL);

Get Input                  scanf("%f", &sum);        READLN (SUM);

                           scanf("%s", &string);     GET (STRING_VAR);

                           scanf("%s", &string);     GET_LINE (STRING_VAR);
                           printf("\n");

                           scanf("%c", &ch);         GET (CH);

                                            (With Text_IO; Use Text_IO;)
Print Output               printf("A = %f\n", A);
                                               Float_IO.PUTLN ('A = ', A);
                                                     
                           printf("A = %f", A);
                                               Float_IO.PUT ('A = ', A);

                           printf("S = %s", S);      PUT('S = ', S);  -or-

                           printf("S = %s\n", S);    PUT_LINE('S = ', S);

                           printf("\n");             NEW_LINE;

                           printf("\n\n\n");         NEW_LINE (ITEM => 3);

                                  May Need:
                                  Package FIO is new float_io(float);
                                  Package IIO is new integer_io(integer);
                                  Package Ada_IO is new ...;

File Output                FILE *file_id;
                           file_id = fopen("filename", "w");
                           ...
                           fprintf(file_id, "Any string here");
                           ...
                           fclose(file_id);

                                            
                                            ...
                                            
                                            ...
                                            


Exit                       exit(1);                  Exit (Package_Name);
                           (Exits main())            (Exits Package_Name)

CONTROL STRUCTURES:
----------------------------------------------------------------------
If-Then-Else               if (x>y) {                IF X > Y THEN
                             ...                       ...
                                                     (No BEGIN/END needed)
                           }                         ELSIF X = Y THEN 
                           else if (x==y) {            ...
                             ...                     ELSE
                           } else {                    ...
                             ...                     END IF;
                           }                         

Case                       switch (my_var) {         CASE MY_VAR IS
                             case 'D' :                WHEN 'D' =>
                               ...                       ...
                               break;                  WHEN 'Y' | 'y' =>
                             case 'Y':                   ...
                             case 'y':                 WHEN OTHERS => NULL;
                               ...                   END CASE;
                               break;
                             default : break;
                           }                         

Loops                      while (1) {               LOOP
                             ...                       ...
                             if (x==y)                 EXIT WHEN X = Y;
                               break;                  ...
                             ...                     END LOOP;
                           }

                           -- or --

                           for (;;) {
                             ...
                             if (x==y)
                               goto exit_label;
                             ...
                           }
                           exit_label:

While Loops                while (count != 5) {      WHILE count /= 5 LOOP
                             ...                       ...
                           }                         END LOOP;

For Loops                  for (i=1;i<=10;i++) {     FOR I IN 1..10 LOOP
                             ...                       ...
                           }                         END LOOP;

                           for (i=10;i>=1;i--) {     FOR I IN REVERSE 1..10 LOOP
                             ...                       ...
                           }                         END LOOP;

Named Loops                N/A                       SUMMATION:
                                                     WHILE COUNT /= 5 LOOP
                                                       ...
                                                     END LOOP SUMMATION;

Block Statements           if (1) {                  SWAP:
                             int temp;               DECLARE
                             temp = v;                 TEMP : INTEGER;
                             v = u;                  BEGIN
                             u = temp;                 TEMP := V;
                           }                           V := U;
                                                       U := TEMP;
                                                     END SWAP;         

Goto                       goto label_text;          GOTO LABEL_TEXT;
                           ...                       ...
                           label_text :              <<LABEL_TEXT>>
                           ...                       ...
C.2     C vs BASIC

Description:               C                         BASIC
======================================================================

ARITHMETIC OPERATORS:
----------------------------------------------------------------------
Addition                   +                         +
Subtraction                -                         -
Multiplication             *                         *
Division (float)           /                         /
Division (integer)         /                         \
Modulus (integer)          %                         MOD
Exponentiation             pow()                     ^


RELATIONAL OPERATORS:
----------------------------------------------------------------------
Greater Than               >                         >
Greater Then or Equal      >=                        >=
Less Than                  <                         <
Less Than or Equal         <=                        <=
Equal                      ==                        =
Not Equal                  !=                        <>


LOGICAL OPERATORS:
----------------------------------------------------------------------
And                        &&                        AND
Or                         ||                        OR
Not                        !                         NOT
Exclusive Or               N/A                       XOR
Implication                N/A                       IMP
Equivalence                ==                        EQV


ASSIGNMENT OPERATORS:
----------------------------------------------------------------------
Assignment                 =                         =
Assignment w/Add           i += 2;                   I = I + (2)
Assignment w/Sub           i -= 4;                   I = I - (4)
Assignment w/Mult          x *= -2.1;                X = X * (-2.1)
Assignment w/Div (float) x /= 8.9;                   X = X / (8.9)
Assignment w/Div (Int)     N/A                       X = X \ (8.9)
Assignment w/Mod           x %= 7.3;                 X = X MOD (7.3)


INCREMENT AND DECREMENT STATEMENTS:
----------------------------------------------------------------------
Post-Increment             i++;                      I = I + 1
Post-Decrement             i--;                      I = I - 1
Pre-Increment              ++i;                      I = I + 1
Pre-Decrement              --i;                      I = I - 1


DATA TYPES:
----------------------------------------------------------------------
Character                  char ch;                  DEFSTR C
                                                     (First letter only)
                                                     -or-  C$
String                     char str[n];              DEFSTR S
                                                     (First letter only)
                                                     -or-  S$
Integer                    int i,j;                  DEFINT I,J
                                                     (First letter only)
                                                     -or-  I, J
Long Integer               long i;                   
Floating Point             float x;                  DEFSNG X
                                                     (First letter only)
                                                     -or-  X!
Double-Precision Float     double x;                 DEFDBL X
                                                     (First letter only)
                                                     -or-  X#
Double Double-Precision    long double x;            
Complex                    fcomplex (naautil.c)      
Arrays                     int A[3];                 DIM A (3)
Enumeration                enum boolean {NO,YES};    
Logical                    N/A                       
Functions                  N/A                       DEF FNname(X)
                                                     (Prefix with FN)


DATA TYPE INITIALIZATION:
----------------------------------------------------------------------
Character                  char ch='c';              CH$ = "c"
String                     char *str="string";       STR$ = "string"
Integer                    int i=5;                  I = 5%  -or-  I = 5
Long Integer               int i=5L;                 
Floating Point             float x=123.4F;           X = 123.4!, X = 123.4
                                                     -or- X!=123.4
Floating Point             float x=1.0e-2F;          X = 1.0E-2
Double-Precision Float     double x=123.4;           X = 123.4#
Double-Precision Float     double x=1e-2;            X = 1.0D-2
Double Double-Precision    long double x=123.4L;     
Double Double-Precision    long double x=1e-2L;      
Complex                    fcomplex c={6.2,7.1};     
Arrays                     int A[3]={4,2,7};         
Enumeration                boolean T=NO;
Constants                  const double x=123.4;     PI# = 3.14
                           #define PI 3.14             (Usage: X = 2 * PI#)
Logical                    N/A                       


DATA TYPE CONVERSION:
----------------------------------------------------------------------
Character                  (char) x                           
String                     (char *) x                "Type Mismatch" ERROR
Integer                    (int) x                   CINT(X)
Long Integer               (long) x                           
Floating Point             (float) x                 CSNG(X)
Double-Precision Float     (double) x                CDBL(X)
Double Double-Precision    (long double) x           
Complex                    (complex) x               


STANDARD FUNCTIONS:
----------------------------------------------------------------------
Truncation                 trunc() (in trunc.c)      FIX()
Round                      round() (in round.c)      CINT()
Nearest Integer            ceil()                    
Nearest Whole Number       floor()                   INT()
Absolute Value             abs(), fabs()             ABS()
Choose Largest             #define MAX(a,b) (a)>(b)?(a):(b)
Choose Smallest            #define MIN(a,b) (a)<(b)?(a):(b)

Square Root                sqrt()                    SQR()
Exponential                exp()                     EXP()
Natural Log                log()                     LOG()
Common Log                 log10()                   LOG(X) / LOG(10)

Sine                       sin()                     SIN()
Cosine                     cos()                     COS() (Load interpreter with
                                                   /D option for doubles)
Tangent                    tan()                     TAN()
Arcsine                    asin()                    ATN(X/SQR(-X*X+1))
Arccosine                  acos()                    -ATN(X/SQR(-X*X+1))
                                                       + 1.5708
Arctangent                 atan()                    ATN()
Atan of Quotient           atan2()                   

Hyperbolic Sine            sinh()                    (EXP(X) - EXP(-X))/2
Hyperbolic Cosine          cosh()                    (EXP(X) + EXP(-X))/2
Hyperbolic Tangent         tanh()                    (EXP(X) - EXP(-X)) / 
                                                       (EXP(X) + EXP(-X))
Random Number              rand(), srand()           RND()  (Returns 0..1)


SYNTAX:
----------------------------------------------------------------------
Case Sensitive?            YES                       NO
Name a program             main()                    
Comment Begin              /*                        '  -or-  REM 
Comment End                */                        <CARRIAGE RETURN>
Begin Symbol               {                         
End Symbol                 }                         END
Statement Terminator       ;                         <CARRIAGE RETURN>
                                                     -or-  ':' followed by
                                                     another command
Statement Separator        ;                         :
Include Files              #include <filename.h>     (Currently not
                                                      supported?)
                           #include "filename.h"
Variable Names             a-zA-Z0-9_                A-Z0-9.
                           (31 chars max.)           (40 chars max.)

Functions                  float func_name (int x, y)
                           {                DEF FNfunc_name (X,Y) = SIN(X)
                             ...                     (256 chars max.)
                             return sin(x);          -or-
                           }

                                   (Load interpreter with /N switch)
                                            DEF FNfunc_name (X,Y)
                                              ...
                                              FNfunc_name = some_float
                                            END DEF

                                                     (Using the /N switch)
Procedures                 proc_name (int x, y)      GOSUB proc_name
                                                     -or- GOSUB line #
(Subroutines)              {                         ...
                             ...                     proc_name:
                           }                           ...
                                                     RETURN

                                                     -or-

                                   (Load interpreter with /N switch)
                                                     SUB sub_name(x#)
                                                       ...
                                                     END SUB
                                            (Usage: CALL sub_name(x#) )

Get Input                  scanf("%f%f", &s1, &s2); INPUT S1, S2

                           printf("Enter sum");      (DEFSNG S)
                           scanf("%f", &sum);        INPUT "Enter sum"; SUM

                           N/A                       READ STR$, NUM1, NUM2
                                                     DATA "Happy", 7.29, 2.0

Print Output               printf("Sum = %f.\n", sum);
                                            PRINT "Sum = "; SUM ;"."

                           printf("Sum = \t%f\t.\n", sum);
                                            PRINT "Sum = ", SUM ,"."
                                                     
                           printf("\n");             PRINT

File Output                FILE *file_id;
                           file_id = fopen("filename", "w");
                           ...
                           fprintf(file_id, "Any string");
                           ...
                           fclose(file_id);

                                            100  OPEN "O", #1, "filename"
                                            ...
                                            200  PRINT#1, "Any string."
                                            ...
                                            300  CLOSE #1

Exit                       exit(1); (Exits main())
                                            RETURN  -or-  STOP


CONTROL STRUCTURES:
----------------------------------------------------------------------
If-Then                    if (x>y) { ... }          IF (X > Y) THEN ...

If-Then-Else               if (x>y) { ... }          IF (X > Y) THEN ... ELSE ...
                           else { ... }                       

                                   (Load interpreter with /N switch)
While Loops                while (count != 5) {      WHILE (logical)
                             ...                       ...
                           }                         WEND

For Loops                  for (i=1;i<=11;i+=2) {    FOR I = 1 TO 11 STEP 2
                             ...                       ...
                           }                         NEXT I

                           for (i=1;i<10;i++) {      FOR I = 1 TO 10-1
                             ...                       ...
                           }                         NEXT I

                           for (i=10;i>=1;i--) {  FOR I = 10 TO 1 STEP -1
                             ...                       ...
                           }                         NEXT I


Case                       switch (my_var) {
                                            (Use If-Then-Else or IF..GOTO)
                             case 'D' :     IF MY_VAR$ = "D" THEN 100
                               ...          IF MY_VAR$ = "Y" THEN 200
                               break;       IF MY_VAR$ = "y" THEN 200
                             case  'Y':     ...
                             case 'y':      100 ...
                               ...          GOTO 400
                               break;       200 ...
                           }                GOTO 400
                                            400 ...

Goto (Logical)             goto label_text;          GOTO 200
                             ...                     ...
                           label_text :              200 ...
                             ...
                                            (Load interpreter with /N
                                                      switch)
                                                     GOTO my_mark
                                                       ...
                                                     my_mark:
                                                       ...

Goto (Computed)            N/A                       ON I GOTO 100,200,300
                                                     100 ...
                                                     200 ...
                                                     300 ...

                                                     -same as-

                           if i==1 goto label1       IF I = 1 THEN 100
                           if i==2 goto label2       IF I = 2 THEN 200
                           if i==3 goto label3       IF I = 3 THEN 300
C.3     C vs C++

Description:               C                         C++
----------------------------------------------------------------------

NOTE: Only additional operators are listed, since "C" is a subset of "C++".

SYNTAX:
----------------------------------------------------------------------
Comment Begin              /*                        //
Comment End                */                        <NEWLINE>

                             (Needs #include <stream.h> or <iostream.h>)
Get Input                  scanf("%f", &sum);        cin >> sum;

                           scanf("%s", &string);     cin >> string;

                           scanf("%c", &ch);         cin >> ch;

                             (Needs #include <stream.h> or <iostream.h>)
Print Output               printf("A = %f\n", A);    cout << A << "\n";
                                                     
                           printf("A = %f", A);      cout << A;

                           printf("S = %s", S);      cout << S;

                           printf("S = %s\n", S);    cout << S << "\n";

                           printf("X = %d", i+1);    cout << "X = " << i+1;

                           printf("\n");             cout << "\n";

Use of Objects             C = My_Matrix_Multiply(A,B);
                                                     C = A * B;

                           X = My_Complex_Multiply(C1,C2);
                                                     X = C1 * C2;
C.4     C vs FORTRAN 77

Description:               C                         FORTRAN 77
======================================================================

ARITHMETIC OPERATORS:
----------------------------------------------------------------------
Addition                   +                         +
Subtraction                -                         -
Multiplication             *                         *
Division                   /                         /
Modulus (integer)          %                         MOD(x,y)
Exponentiation             pow()                     **


RELATIONAL OPERATORS:
----------------------------------------------------------------------
Greater Than               >                         .GT.              
Greater Then or Equal      >=                        .GE.
Less Than                  <                         .LT.
Less Than or Equal         <=                        .LE.
Equal                      ==                        .EQ.
Not Equal                  !=                        .NE.


LOGICAL OPERATORS:
----------------------------------------------------------------------
And                        &&                        .AND.
Or                         ||                        .OR.
Not                        !                         .NOT.
Equivalent                 N/A                       .EQV.
Not Equivalent             N/A                       .NEQV.


ASSIGNMENT OPERATORS:
----------------------------------------------------------------------
Assignment                 =                         =
Assignment w/Add           i += 2;                   I = I + (2)
Assignment w/Sub           i -= 4;                   I = I - (4)
Assignment w/Mult          x *= -2.1;                X = X * (-2.1)
Assignment w/Div           x /= 8.9;                 X = X / (8.9)
Assignment w/Mod           x %= 7.3;                 X = MOD(X, 7.3)


INCREMENT AND DECREMENT STATEMENTS:
----------------------------------------------------------------------
Post-Increment             i++;                      I = I + 1
Post-Decrement             i--;                      I = I - 1
Pre-Increment              ++i;                      I = I + 1
Pre-Decrement              --i;                      I = I - 1


DATA TYPES:
----------------------------------------------------------------------
Character                  char ch;                  CHARACTER*1 CH
                                                     CHARACTER CH
String                     char str[n];              CHARACTER*n STR
                                                     CHARACTER STR*n
Integer                    int i,j;                  INTEGER I,J
                                                     INTEGER*4 I,J
                                                     INTEGER*1 I,J
                                                     (Machine dependant)
                                                     INTEGER*2 I,J
                                                     (Machine dependant)
Long Integer               long i;                   INTEGER*2 I
                                                     (Machine dependant)
Floating Point             float x;                  REAL X
                                                     REAL*4 X
Double-Precision Float     double x;                 DOUBLE PRECISION X
                                                     REAL*8 X
Double Double-Precision    long double x;            
Complex                    fcomplex (naautil.c)      COMPLEX C
Arrays                     int A[3][2];              INTEGER A(3,2)  -or-
                                                     INTEGER A
                                                     DIMENSION A(3,2)
Enumeration                enum boolean {NO,YES};    
Logical                    N/A                       LOGICAL A,B


DATA TYPE INITIALIZATION:     (Use variables as declared above first)
----------------------------------------------------------------------
Character                  char ch='c';              DATA CH/'c'/
String                     char *str="string";       DATA STR/'string'/
Integer                    int i=5;                  DATA I/5/
Long Integer               int i=5L;                 DATA I/5/
Floating Point             float x=123.4F;           DATA X/123.4/
Floating Point             float x=1.0e-2F;          DATA X/1.E-2/
Double-Precision Float     double x=123.4;           DATA X/123.4D0/
Double-Precision Float     double x=1e-2;            DATA X/1.D-2/
Double Double-Precision    long double x=123.4L;     
Double Double-Precision    long double x=1e-2L;      
Complex                    fcomplex c={6.2,7.1};     DATA C/(6.2,7.1)/
Arrays                     int A[3][2]={{1,2},{3,4},{5,6}};
                                                     DATA A/1,3,5,2,4,6/
Enumeration                boolean T=NO;
Constants                  const double x=123.4;     REAL*8 X,PI
                           #define PI 3.14           PARAMETER(X=123.4D0)
                                                     PARAMETER(PI=3.14)
Logical                    N/A              DATA A,B/.FALSE.,.TRUE.)/


DATA TYPE CONVERSION:
----------------------------------------------------------------------
Character                  (char) x                  CHAR(X)
String                     (char *) x                
Integer                    (int) x                   INT(X)
                                                     FORTRAN 66: IFIX(X), IDINT(X)
Long Integer               (long) x
Floating Point             (float) x                 REAL(X)
                                                     FORTRAN 66:
                                                       SNGL(X), FLOAT(X)
Double-Precision Float     (double) x                DBLE(X)
Double Double-Precision    (long double) x
Complex                    (complex) x               CMPLX(X)


STANDARD FUNCTIONS:
----------------------------------------------------------------------
Truncation                 trunc() (in trunc.c)      AINT(), DINT()
Round                      round() (in round.c)      ANINT()
Nearest Integer            ceil()                    NINT(), IDNINT()
Nearest Whole Number       floor()                   ANINT(), DNINT()
Absolute Value             abs(), fabs()             ABS(), IABS(), DABS(), CABS()
Choose Largest             #define MAX(a,b) (a)>(b)?(a):(b)
                                                     MAX(), MAX0(),
                                                     MAX1(), DMAX1()
                                                     FORTRAN 66: AMAX0(), AMAX1()
Choose Smallest            #define MIN(a,b) (a)<(b)?(a):(b)
                                                     MIN(), MIN0(),
                                                     MIN1(), DMIN1()
                                                     FORTRAN 66:
                                                       AMIN0(), AMIN1()
Square Root                sqrt()                    SQRT(), DSQRT(),
                                                     CSQRT()
Exponential                exp()                     EXP(), DEXP(), CEXP()
Natural Log                log()                     LOG(), ALOG(),
                                                     DLOG(), CLOG()
Common Log                 log10()                   LOG10(), ALOG10(),
                                                     DLOG10()

Sine                       sin()                     SIN(), DSIN(), CSIN()
Cosine                     cos()                     COS(), DCOS(), CCOS()
Tangent                    tan()                     TAN(), DTAN()
Arcsine                    asin()                    ASIN(), DASIN()
Arccosine                  acos()                    ACOS(), DACOS()
Arctangent                 atan()                    ATAN(), DATAN()
Atan of Quotient           atan2()                   ATAN2(,), DATAN2(,)

Hyperbolic Sine            sinh()                    SINH(), DSINH()
Hyperbolic Cosine          cosh()                    COSH(), DCOSH()
Hyperbolic Tangent         tanh()                    TANH(), DTANH()
Random Number              rand(), srand()           


SYNTAX:
----------------------------------------------------------------------
Case Sensitive?            YES                       NO
Name a program             main()                    PROGRAM prog_name
Comment Begin              /*                        'C'  -or-  '*' in
                                                     column 1
Comment End                */                        <CARRIAGE RETURN>
Begin Symbol               {                         
End Symbol                 }                         END  w/any character
                                                     except '0' or <SPACE>
                                                     in column 6       
Statement Terminator       ;                         <CARRIAGE RETURN>
Include Files              #include <filename.h>
                                            $INCLUDE : 'FILENAME.INC'
                           #include "filename.h"
Variable Names             a-zA-Z0-9_                A-Z0-9
                           (31 chars max.)           (6 chars max.)

Functions                  float func_name (int x, y)
                           {
                             ...
                             return some_float;
                           }
                                            REAL FUNCTION FNAME (X,Y)
                                              ...
                                            FNAME = SOMEREAL
                                            RETURN
                                            END

                                            -or-

                                            FUNCTION FNAME (X,Y)
                                            REAL FNAME
                                              ...
                                            FNAME = SOMEREAL
                                            RETURN
                                            END

Procedures                 proc_name (int x, y) SUBROUTINE SUB_NAME (X,Y)
(Subroutines)              {                           ...
                             ...                 RETURN
                           }                     END

Get Input                  scanf("%f", &sum);        READ *,SUM

                           scanf("%c", &ch);            READ (4,7) CH
                                                     7  FORMAT (A1)

Print Output               printf("A = %f\n", A);    PRINT *, 'A = ', A/

                           printf("A = %f", A);      PRINT *, 'A = ', A

                                                     -or-

                                                     WRITE (*,8) A
                                                     8  FORMAT('1',F8.8)

                           printf("\n");             PRINT*

                                                     -or-

                                                     WRITE(*,'(/)')

                                                     -or-

                                                        WRITE (*,9)
                                                     9  FORMAT(/)

File Output                FILE *file_id;
                           file_id = fopen("filename", "w");
                           ...
                           fprintf(file_id, "Any string\n");
                           ...
                           fclose(file_id);

                                   OPEN (UNIT=4, FILE='FILE_NAME')
                                   ...
                                   WRITE (4,8)
                                   FORMAT ('1',2X,'Any string',/)
                                   ...
                                   CLOSE (4)         

Exit                       exit(1); (Exits main())
                                            RETURN  -or-  STOP


CONTROL STRUCTURES:
----------------------------------------------------------------------
If-Then                    if (x>y) {                IF (X.GT.Y) THEN
                             ...                       ...
                           }                         ENDIF

If-Then-Else               if (x>y) {                IF (X.GT.Y) THEN
                             ...                       ...
                           }                           ...
                           else if (x==y) {          ELSE IF (X.EQ.Y) THEN
                             ...                       ...
                           } else {                  ELSE
                             ...                       ...
                           }                         ENDIF

Arithmetic If              if (x>y) ...     (For FORTRAN 66 compatibility)
                                                     IF (X.GT.Y) ...
                                                     (limited)

                                            (Not in ANSI FORTRAN 77)
While Loops                while (count != 5) {      DO WHILE (logical)
                             ...                       ...
                           }                         END DO

For Loops                  for (i=1;i<=11;i+=2) {    DO 30 I=1,11,2
                             ...                       ...
                           }                         30 CONTINUE

                           for (i=10;i>=1;i--) {     DO 30 I=10,1,-1
                             ...                       ...
                           }                         30 CONTINUE

Case                       switch (my_var) {         (Use If-Then-Else)
                             case 'D' :
                               ...
                               break;                
                             case 'Y':
                             case 'y':
                               ...                   
                               break;
                           }                

Goto (Logical)             goto label_text;          GOTO S1
                                                     (S1 is in [1..99999])
                             ...                       ...
                           label_text :              S1 ...
                                                     (S1 is in col 1-5)
                             ...

Goto (Computed IF)         N/A              (For FORTRAN 66 compatibility)
                                                     GOTO (S1, S2,...Sn) I
                                                     S1 ...
                                                     S2 ...
                                                     Sn ...

                                                     -or-

                                            (For FORTRAN 66 compatibility)
                                                     GOTO I, (S1, S2,...Sn)
                                                     S1 ...
                                                     S2 ...
                                                     Sn ...

                                                     -same as-

                           if i==1 goto label1       IF (I.EQ.1) GOTO S1
                           if i==2 goto label2       IF (I.EQ.2) GOTO S2
                           if i==n goto labeln       IF (I.EQ.n) GOTO Sn

Goto (Arithmetic IF)       N/A                       (Use is discouraged)
                                            IF (arith_exp < 0) S1, S2, S3

                                            -same as-

                                            IF (arith_exp < 0) GOTO S1
                                            IF (arith_exp = 0) GOTO S2
                                            IF (arith_exp > 0) GOTO S3
C.5     C vs Pascal

Description:               C                         Pascal
======================================================================

ARITHMETIC OPERATORS:
----------------------------------------------------------------------
Addition                   +                         +
Subtraction                -                         -
Multiplication             *                         *
Division (real)            /                         /
Division (integer)         /                         DIV
Modulus (real)             fmod(), modf()            N/A
Modulus (integer)          %                         MOD
Exponentiation             pow()                     --- NOT STANDARD ---


RELATIONAL OPERATORS:
----------------------------------------------------------------------
Greater Than               >                         >
Greater Then or Equal      >=                        >=
Less Than                  <                         <
Less Than or Equal         <=                        <=
Equal                      ==                        =
Not Equal                  !=                        <>


LOGICAL OPERATORS:
----------------------------------------------------------------------
And                        &&                        AND
Or                         ||                        OR
Not                        !                         NOT


ASSIGNMENT OPERATORS:
----------------------------------------------------------------------
Assignment                 =                         :=
Assignment w/Add           i += 2;                   I := I + (2);
Assignment w/Sub           i -= 4;                   I := I - (4);
Assignment w/Mult          x *= -2.1;                X := X * (-2.1);
Assignment w/Div           x /= 8.9;                 X := X / (8.9);
Assignment w/Mod           x %= 7.3;                 X := X MOD (7.3);


INCREMENT AND DECREMENT STATEMENTS:
----------------------------------------------------------------------
Post-Increment             i++;                      I := I + 1;
Post-Decrement             i--;                      I := I - 1;
Pre-Increment              ++i;                      I := I + 1;
Pre-Decrement              --i;                      I := I - 1;


DATA TYPES:                                          (Precede with VAR)
----------------------------------------------------------------------
Character                  char                      CHAR
String                     char str[n];              STRING[n]
                           char * (pointer only)     STRING
                                                     (default size of 80)
Integer                    int                       INTEGER
Long Integer               long                      
Floating Point             float                     REAL
Double-Precision Float     double           
Double Double-Precision    long double               
Complex                    fcomplex (naautil.c)      (Create a record)
Arrays                     float A[3][2];            A : ARRAY [1..3,1..2]
                                                     OF REAL
Enumeration                enum boolean {NO,YES};    TYPE ANS = (NO, YES);
Boolean                                              BOOLEAN
Pointers                   int *ptr;                 PTR = ^INTEGER;
Structures                 struct complex {          TYPE COMPLEX_TYPE =
                                                          RECORD
                             float r, i;                    R, I : REAL
                           };                             END;
File Pointers              FILE *fptr;               TEXT
Ranges                                               I : 1..80;


DATA TYPE INITIALIZATION:
----------------------------------------------------------------------
Character                  char ch = 'c';            CH := 'c';
String                     char *str = "A string";   STR := 'A string';
Integer                    int i = 5;                I := 5;
Long Integer               int i = 5L;               
Floating Point             float x = 123.4F;         X := 123.4;
Floating Point             float x = 1.0e-2F;        X := 1.0E-2;
Double-Precision Float     double x = 123.4;                  
Double-Precision Float     double x = 1e-2;                   
Double Double-Precision    long double x = 123.4L;   
Double Double-Precision    long double x = 1e-2L;    
Complex                    fcomplex c = {6.2,7.1};   (Create a record)
Arrays                     float A[3][2] = {{4,2},{1,-2},{0,5}};       
                                                     A(2,2) := -2;
Enumeration                boolean ANS = NO;         TYPE ANS = (NO, YES);
Boolean                                              VAR BOOLEAN FOUND;
                                                     FOUND := FALSE;
Pointers                   char *, ... *             ^
Structures                 struct complex {          RECORD1 := RECORD2;
                             float r = 12.0;                    
                             float i = 7.0;                     
                           };                          
File Pointers              FILE *fptr;               OUTFILE : TEXT;
Ranges                                               I := 39;
                                                     (1..80 is valid above)
Constants                  #define PI 3.1415         CONST PI = 3.1415;
                           const char DOLLAR = '$'; CONST DOLLAR = '$';


DATA TYPE CONVERSION:
----------------------------------------------------------------------
Character                  (char) i                  CHR(ORD(0) + i);
                                                     (where i = 0..9)
String                     (char *) x                
Integer                    (int) ch                  ORD(ch) - ORD('0');
                                                     (where ch = '0'..'9')
Long Integer               (long) x
Floating Point             (float) x                 (INTEGERs migrate up
                                                     to REALs)
Double-Precision Float     (double) x                
Double Double-Precision    (long double) x
Complex                    (complex) x               


STANDARD FUNCTIONS:
----------------------------------------------------------------------
Truncation                 trunc() (in trunc.c)      TRUNC()
Round                      round() (in round.c)      ROUND()
Nearest Integer            ceil()                    
Nearest Whole Number       floor()                   
Absolute Value             abs(), fabs()             ABS()
Odd (INTEGER)              #define ODD(a) (a%2)?(1):(0)       ODD()

Square Root                sqrt()                    SQRT()
Square                                               SQR()
Exponential                exp()                     EXP()
Natural Log                log()                     LN()
Common Log                 log10()                   (LN() / LN(10.0))
Power of Ten (INTEGER)     pow(10.0,x)               PWROFTEN(X)

Sine                       sin()                     SIN()
Cosine                     cos()                     COS()
Tangent                    tan()                     (SIN() / COS())
Arcsine                    asin()                    ATAN(X/SQR(-X*X+1))
Arccosine                  acos()                    -ATAN(X/SQR(-X*X+1))
                                                      + 1.5708
Arctangent                 atan()                    ATAN()
Atan of Quotient           atan2()                   

Hyperbolic Sine            sinh()                    ((EXP(X) + EXP(-X))
                                                        / 2.0)
Hyperbolic Cosine          cosh()                    ((EXP(X) - EXP(-X))
                                                        / 2.0)
Hyperbolic Tangent         tanh()                    (EXP(X) - EXP(-X)) / 
                                                       (EXP(X) + EXP(-X))
Random Number              rand(), srand()           


SYNTAX:
----------------------------------------------------------------------
Case Sensitive?            YES                       NO
Name a program             main()                    PROGRAM prog_name;
Comment Begin              /*                        (*  -or-  {
Comment End                */                        *)  -or-  }
Begin Symbol               {                         BEGIN
End Symbol                 }                         END  -or-  END.
                                                     (last one only)
Statement Terminator       ;                         ;  -or-  Nothing if
                                                     preceding an END or
                                                     ELSE statement
Include Files              #include <filename.h>     {$I FILENAME.INC}
                           #include "filename.h"
Variable Names             a-zA-Z0-9_                A-Z0-9
                           (31 chars max.)           (? chars max.)

Functions                  float func_name (int x, y)
                           {
                             ...
                             return some_float;
                           }
                                   FUNCTION FNAME (X,Y: REAL) : REAL;
                                     ...
                                   FNAME := SOMEREAL;

Procedures                 proc_name (int x, y)
                                   PROCEDURE PROC_NAME (X,Y: REAL);

Get Input                  scanf("%f", &sum);        READLN (SUM);

                           scanf("%c", &ch);         READ (CH);

Print Output               printf("A = %f\n", A);    WRITELN ('A = ', A);

                           printf("A = %f", A);      WRITE ('A = ', A);

                           printf("\n");             WRITELN;

File Output                #include <stdio.h>
                           FILE *file_id;
                           file_id = fopen("filename", "w");
                           ...
                           fprintf(file_id, "Any string here\n");
                           ...
                           fclose(file_id);

                                   VAR file_id : TEXT;
                                   ASSIGN (file_id, outfile);
                                   REWRITE (file_id);
                                   ...
                                   WRITELN (file_id, 'Any string.');
                                   ...
                                   CLOSE (file_id);

Exit                       exit(1); (Exits main())
                                                     Exit (block name)


CONTROL STRUCTURES:
----------------------------------------------------------------------
If-Then-Else               if (x>y)                  IF X > Y THEN
                           {                           BEGIN
                             ...                         ...
                           }                           END
                           else if (x==y) {          ELSE IF X = Y THEN
                             ...                       ...
                           } else {                  ELSE
                             ...                       ...
                           }

While Loops                while (count != 5)        WHILE count <> 5 DO
                           {                         BEGIN
                             ...                      ...
                           }                         END

For Loops                  for (i=1;i<=10;i++)       FOR I := 1 TO 10 DO
                           {                         BEGIN
                             ...                      ...
                           }                         END

                           for (i=10;i>=1;i--)       FOR I := 10 DOWNTO 1
                           {                         DO BEGIN
                             ...                      ...
                           }                         END

Case                       switch (my_var) {         CASE MY_VAR OF
                             case 'D' :                'D' : BEGIN
                               ...                              ...
                               break;                         END;
                             case 'Y': case 'y':    'Y', 'y' : ...
                               ...                   ("break" not needed)  
                               break;                
                           }                         END

Repeat                     do {                      REPEAT
                             ...                       ...
                                                     (No BEGIN/END needed)
                           } while (i < 7);          UNTIL (I < 7);

With                       No equivalent             (From RECORD variable
                                                     ME.SSAN)
                                                     WITH record_var DO
                                                       SSAN := 1234567890;

Goto                       goto label_text;          LABEL 20, 30;
                           ... label_text : ...      GOTO label_number
                                                     (1..9999)
                                                     ... label_number : ...
Appendix D:       Sample Programs in Other Languages


This appendix is long, but important.  It lists the example programs
of Simpson's Composite Rule for Integration - Algorithm 4.1, in six
different languages!  Each of these programs can be found in the LANGS
sub-directory of the distribution diskettes.  These files are
organized as follows:

                            LANGS
                              ≥
   ⁄ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒ¡ƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒø   
   ˛           ˛           ˛           ˛           ˛           ˛ 
  ADA        BASIC         C          C++       FORTRAN      PASCAL  
   ˛           ˛           ˛           ˛           ˛           ˛ 
SIMPSON.ADA SIMPSON.BAS SIMPSON.C  SIMPSON.CPP SIMPSON.FOR SIMPSON.PAS
NAAUTIL.ADA SIMPSON.IN  SIMPSON.H  SIMPSON.HPP SIMPSON.IN  NAAUTIL.INC
SIMPSON.IN  SIMPSON.OUT SIMPSON.IN SIMPSON.IN  SIMPSON.OUT NAAMATH.INC
SIMPSON.OUT            SIMPSON.OUT SIMPSON.OUT             SIMPSON.IN
                                                           SIMPSON.OUT

Refer to Section 5.4 - "Language Comparison Charts" for more
information about these programs.
         D.1      Ada


         D.1.1    SIMPSON.ADA

-- FILE NAME: SIMPSON.ADA
-- LANGUAGE:  ADA
-- COMPILER:  Meridian Ada 4.1
-- STATUS:    Not tested yet

-- ****************************************************************************
--                Composite Simpson's Rule - Algorithm 4.1
-- ****************************************************************************
--
--                                 Ùb
-- To approximate the integral I = ≥  f(x) dx:
--                                 ıa
--
-- INPUT endpoints a, b; positive integer n; the function f():
--
-- OUTPUT approximation XI to I.
--
-- ****************************************************************************
-- *      Written by:  Harold A. Toomey, CARE-FREE SOFTWARE, 2Q 1991, v4.0     *
-- ****************************************************************************

with naa_util; use naa_util;       -- Numerical Analysis Algorithms utilities
with math_lib; use math_lib;       -- Contains several useful math functions
with text_io;  use text_io;        -- For file I/O
with ada_io;   use ada_io;         -- For easier text, integer and float I/O
                                   -- NOTE: ada_io is supplied with the Meridian
                                   -- Ada Compiler

procedure simpson is

  -- *************
  -- * constants *
  -- *************

  -- NOTE: PI is defined in the package math_lib to 40 decimal places.
  outfile   : constant := "simpson.out";    -- Default name of the output file
  eq_text_f : constant := "f(x) = sin(x)";  -- Needs updating  $

  -- *********
  -- * types *
  -- *********
  type file_type is limited private;

  -- *************
  -- * variables *
  -- *************

  a, b, h, x, xi, xi0, xi1, xi2 : float;
  n       : positive;
  title   : string(1..80);
  file_id : file_type;

  -- **********************************
  -- * LOCAL PROCEDURES AND FUNCTIONS *
  -- **********************************

  -- **************************************************************************
  -- * f(x) - Function to evaluate, f(x).  Needs updating $.                 *
  -- **************************************************************************
  function f(x : in float) return float is
  begin  -- f
    return (sin(x));
  end f;

  -- **************************************************************************


-- ********
-- * MAIN *
-- ********

begin

  -- **********
  -- * INPUTS *
  -- **********

  title := get_title;              -- Prompts for optional comments

  put_line ("Composite Simpson's Rule - Algorithm 4.1");
  new_line;
  put ("Enter endpoint a: ");
  get_line (a);
  put ("Enter endpoint b: ");
  get_line (b);

  loop
    put ("Enter number of intervals on [a,b], n: ");
    get_line (n);

--  Place an exception handler here for better use of ADA.
    if n <= 0 then                 -- ERROR - n can not be negative.
      put_line ("ERROR - n must be greater than zero.");
    end if;

    exit when n > 0;
  end loop;

  -- *************
  -- * ALGORITHM *
  -- *************

  -- STEP #1
  h := (b - a)/n;

  -- STEP #2
  xi0 := f(a) + f(b);
  xi1 := 0.0;                      -- Summation of f(x(2i-1))
  xi2 := 0.0;                      -- Summation of f(x(2i))

  -- STEP #3
  for i in 1..n-1 loop

      -- STEP #4
      x := a + i*h;

      -- STEP #5
      if i mod 2 = 0 then
        xi2 := xi2 + f(x);         -- For even i
      else
        xi1 := xi1 + f(x);         -- For odd i
      end if;

  end loop;

  -- STEP #6
  xi := h*(xi0 + 2.0*xi2 + 4.0*xi1) / 3.0;

  -- ***********
  -- * OUTPUTS *
  -- ***********

  -- STEP #7
  -- Write output to the screen.
  print_title (title);

  put_line ("Composite Simpson`s Rule - Algorithm 4.1");
  new_line;
  put_line (eq_text_f, " from ", a, " to ", b, ".");
  new_line;
  put_line ("n = ", n, " intervals on [a,b].");
  put_line ("Interval number h = ", h);
  new_line;
  put_line ("     Ù", b);
  put_line ("XI = ≥  f(x) dx = ", xi);
  put_line ("     ı", a);
  new_line;
  put_line ("Required ", n+1, " functional evaluations.");

  -- Write output to a file.
  -- Open outfile for output.
  create (file => file_id, mode => out_file, name => outfile);         -- See 14.3.10

  print_title_to_outfile (file_id, title);

  new_line (file_id);
  put_line (file_id, "Composite Simpson`s Rule - Algorithm 4.1");
  new_line (file_id);
  put_line (file_id, eq_text_f, " from ", a, " to ", b, ".");
  new_line (file_id);
  put_line (file_id, "n = ", n, " intervals on [a,b].");
  put_line (file_id, "Interval number h = ", h);
  new_line (file_id);
  put_line (file_id, "     Ù", b);
  put_line (file_id, "XI = ≥  f(x) dx = ", xi);
  put_line (file_id, "     ı", a);
  new_line (file_id);
  put_line (file_id, "Required ", n+1, " functional evaluations.");
  close (file => file_id);                  -- Closes output file.

  new_line;
  put_line ("Output saved into file '", outfile, "'.");

end simpson;                                -- STOP

-- ****************************************************************************
-- *         Copyright (C) 1991, Harold A. Toomey, All Rights Reserved.             *
-- ****************************************************************************


         D.1.2    NAAUTIL.ADA

-- ****************************************************************************
-- * PACKAGE:  NAA_UTIL.ADA                                                           *
-- * VERSION:  4.0                                                            *
-- *                                                                          *
-- * WRITTEN BY:  Harold A. Toomey, CARE-FREE SOFTWARE                        *
-- * DATE:        22 May 1991  (2Q 1991)                                      *
-- *                                                                          *
-- * DESCRIPTION:                                                             *
-- *   Contains useful utilities (functions and procedures) to be used with   *
-- *   "Numerical Analysis Algorithms in Ada" v4.0.                           *
-- *                                                                          *
-- * VARIABLES:                                                               *
-- *   numchars : integer;                                                    *
-- *                                                                          *
-- * FUNCTIONS:                                                               *
-- *   get_title()                                                            *
-- *                                                                          *
-- * PROCEDURES:                                                              *
-- *   print_title()                                                          *
-- *   print_title_to_file()                                                  *
-- *                                                                          *
-- ****************************************************************************

with ada_io;  use ada_io;

-- ****************************************************************************
--  Package specification
-- ****************************************************************************
package NAA_UTIL is

  numchars : integer;              -- Stores title length in characters.

  function get_title return string;

  procedure print_title(
      file_id : in file_type;
      title   : in string
  );

  procedure print_title_to_outfile(
      file_id : in file_type;
      title   : in string
  );

end NAA_UTIL;


-- ****************************************************************************
--  Package body
-- ****************************************************************************

package body NAA_UTIL is

-------------------------------------------------------------------------------
-- get_title() - Prompts for an optional title.
-------------------------------------------------------------------------------

function get_title return string is
  title : string(1..80);
begin  -- get_title
  for i in 1..79 loop              -- Print the NAA banner
    put ("-");
  end loop;
  new_line;
  put_line(ht, ht, "'Numerical Analysis Algorithms in Ada' v4.0");
  for i in 1..79 loop
    put ("-");
  end loop;
  new_line;                        -- Get the title
  put_line ("Enter a title [ie - Set 2.1,  Problem 2 a) ].");
  put ("----> ");
  get_line (title);
  numchars := title'length;        -- Numchars stores the length of the title.
  return (title);
end get_title;


-------------------------------------------------------------------------------
-- print_title() - Prints NAA banner and title to the screen.
-------------------------------------------------------------------------------

procedure print_title (file_id : in file_type, title : in string) is
begin  -- print_title
  for i in 1..79 loop              -- Print the NAA banner
    put ("-");
  end loop;
  new_line;
  put_line(ht, ht, "'Numerical Analysis Algorithms in Ada' v4.0");
  for i in 1..79 loop
    put ("-");
  end loop;
  new_line;
  if numchars > 0 then
    put_line (title);              -- Print the title
    new_line;
  end if;
end print_title;


-------------------------------------------------------------------------------
-- print_title_to_outfile() - Prints NAA banner and title to the output file.
-------------------------------------------------------------------------------

procedure print_title_to_outfile (file_id : in file_type, title : in string) is
begin  -- print_title_to_outfile
  for i in 1..79 loop              -- Print the NAA banner
    put (file_id, "-");
  end loop;
  new_line (file_id);
  put_line(file_id, ht, ht, "'Numerical Analysis Algorithms in Ada' v4.0");
  for i in 1..79 loop
    put (file_id, "-");
  end loop;
  new_line (file_id);
  if numchars > 0 then
    put_line (file_id, title);     -- Print the title
    new_line (file_id);
  end if;
end print_title_to_outfile;

-------------------------------------------------------------------------------


end NAA_UTIL;     -- end package body NAA_UTIL

-- ****************************************************************************
-- *        Copyright (C) 1991, Harold A. Toomey, All Rights Reserved.             *
-- ****************************************************************************


         D.1.3    SIMPSON.IN

NAA v4.0 Sample Output
0.0
3.14159265358979324
20


         D.1.4    SIMPSON.OUT

------------------------------------------------------------------------------
                  'Numerical Analysis Algorithms in Ada' v4.0
------------------------------------------------------------------------------

NAA v4.0 Sample Output

Composite Simpson's Rule - Algorithm 4.1

f(x) = sin(x) from 0 to 3.14159.

n = 20 intervals on [a,b].
Interval number h = 0.15708

     Ù3.14159
XI = ≥  f(x) dx = 2.0000067844
     ı0

Required 21 functional evaluations.
        D.2      BASIC


         D.2.1    SIMPSON.BAS

10  'FILE NAME: SIMPSON.BAS
20  'LANGUAGE:  BASIC
30  'COMPILER:  Microsoft GW-BASIC Version 3.20
40  'STATUS:    Compiles and runs correctly
50  '
60  '**************************************************************************
70  '             Composite Simpson's Rule - Algorithm 4.1
80  '**************************************************************************
90  '
100 '                                  Ùb
110 '  To approximate the integral I = ≥  f(x) dx:
120 '                                  ıa
130 '
140 '  INPUT endpoints a, b; positive integer n; the function fnf().
150 '
160 '  OUTPUT approximation XI to I.
170 '
180 '**************************************************************************
190 '  Written by:  Harold A. Toomey, CARE-FREE SOFTWARE, 2Q 1991, v4.0
200 '**************************************************************************
210 '
220  PI# = 3.141592653589793#      'The constant PI (Usage: X = 2 * PI# )
230  OUTFILE$ = "SIMPSON.OUT"      'Output file name
240  EQTEXTF$ = "f(x) = sin(x)"    'Needs updating  $
250 '
260  DEFDBL A, B, H, X             'For XI, XI0, XI1, and XI2 also
270  DEFINT I, N
280  DEFSTR T                      'For title
290 '     
300 '**************************************************************************
310 '* FNF(X) - Function to evaluate, f(x).  Needs updating $.
320 '**************************************************************************
330  DEF FNF(X) = SIN(X)
340 '**************************************************************************
350 '
360 '**********
370 '* INPUTS *
380 '**********
390 '
400 'Get the optional title
410  PRINT "------------------------------------------------------------------"
420  PRINT "           'Numerical Analysis Algorithms in BASIC' v4.0          "
430  PRINT "------------------------------------------------------------------"
440  PRINT
450  PRINT "Enter a title [ie - Set 2.1,  Problem 2 a) ]."
460  INPUT "----->"; TITLE$
470 '
480  PRINT
490  PRINT "Composite Simpson's Rule - Algorithm 4.1"
500  PRINT
510  INPUT "Enter endpoint a = "; A
520  INPUT "Enter endpoint b = "; B
530  INPUT "Enter number of intervals on [a,b], n = "; N
540 '
550 'ERROR - N must be positive
560  IF (N <= 0) THEN PRINT "ERROR - n must be greater than zero.": GOTO 530
570 '
580 '*************
590 '* ALGORITHM *
600 '*************
610 '
620 'STEP #1
630  H = (B - A) / N
640 '
650 'STEP #2
660  XI0 = FNF(A) + FNF(B)
670  XI1 = 0!                      'Summation of f(x(2i-1))
680  XI2 = 0!                      'Summation of f(x(2i))
690 '
700 'STEP #3
710  FOR  I = 1 TO N - 1
720 '
730 '  STEP #4
740    X = A + I*H
750 '
760 '  STEP #5                (For even i)             (For odd i)
770    IF (I MOD 2 = 0)  THEN XI2 = XI2 + FNF(X)  ELSE XI1 = XI1 + FNF(X)
780 '
790  NEXT I
800 '
810 'STEP #6
820  XI = H * (XI0 + 2*XI2 + 4*XI1) / 3
830 '
840 '***********
850 '* OUTPUTS *
860 '***********
870 '
880 'STEP #7
890 'Write output to the SCREEN
900  PRINT "------------------------------------------------------------------"
910  PRINT "           'Numerical Analysis Algorithms in BASIC' v4.0          "
920  PRINT "------------------------------------------------------------------"
930  PRINT
940  PRINT TITLE$                  'Print optional title
950  PRINT
960  PRINT "Composite Simpson's Rule - Algorithm 4.1"
970  PRINT
980  PRINT EQTEXTF$, " from"; A ;"to"; B ;"."
990  PRINT
1000  PRINT "n ="; N ;"intervals on [a,b]."
1010  PRINT "Interval number h ="; H
1020  PRINT
1030  PRINT "     Ù"; B
1040  PRINT "XI = ≥  f(x) dx = "; XI
1050  PRINT "     ı"; A
1060  PRINT
1070  PRINT "Required"; N+1 ;"functional evaluations."
1080 '
1090 'Write output to a FILE
1100  OPEN "O", #1, OUTFILE$       'Create or open the file "041.OUT"
1110  PRINT#1, "--------------------------------------------------------------"
1120  PRINT#1, "        'Numerical Analysis Algorithms in BASIC' v4.0         "
1130  PRINT#1, "--------------------------------------------------------------"
1140  PRINT#1,
1150  PRINT#1, TITLE$              'Print optional title
1160  PRINT#1,
1170  PRINT#1, "Composite Simpson's Rule - Algorithm 4.1"
1180  PRINT#1,
1190  PRINT#1, EQTEXTF$, " from"; A ;"to"; B ;"."
1200  PRINT#1,
1210  PRINT#1, "n ="; N ;"intervals on [a,b]."
1220  PRINT#1, "Interval number h ="; H
1230  PRINT#1,
1240  PRINT#1, "     Ù"; B
1250  PRINT#1, "XI = ≥  f(x) dx = "; XI
1260  PRINT#1, "     ı"; A
1270  PRINT#1,
1280  PRINT#1, "Required"; N + 1 ;"functional evaluations."
1290  CLOSE #1
1300 '
1310  PRINT
1320  PRINT "Output saved into file '"; OUTFILE$; "'."
1330  END                          'STOP
1340 '
1350 '************************************************************************
1360 '  Copyright (C) 1991, Harold A. Toomey, All Rights Reserved.
1370 '*************************************************************************


         D.2.2    SIMPSON.IN

NAA v4.0 Sample Output
0.0
3.14159265358979324
20


         D.2.3    SIMPSON.OUT

--------------------------------------------------------------
        'Numerical Analysis Algorithms in BASIC' v4.0         
--------------------------------------------------------------

NAA 4.0 Sample Output

Composite Simpson's Rule - Algorithm 4.1

f(x) = sin(x)  from 0 to 3.14159265358979 .

n = 20 intervals on [a,b].
Interval number h = .1570796326794895 

     Ù 3.14159265358979 
XI = ≥  f(x) dx =  2.000006886810941 
     ı 0 

Required 21 functional evaluations.
        D.3      C


         D.3.1    SIMPSON.C

/*
**  FILE NAME: SIMPSON.C
**  LANGUAGE:  C
**  COMPILERS: Any ANSI C Compiler  (Microsoft C 5.0, Turbo C 2.0, etc.)
**  STATUS:    Compiles and runs correctly
*/

/******************************************************************************
                  Composite Simpson's Rule - Algorithm 4.1
*******************************************************************************

                                Ùb
To approximate the integral I = ≥  f(x) dx:
                                ıa

INPUT endpoints a, b; positive integer n; the function f().

OUTPUT approximation XI to I.

*******************************************************************************
*        Written by:  Harold A. Toomey, CARE-FREE SOFTWARE, 2Q 1991, v4.0      *
******************************************************************************/

#include "naautil.h"               /* Numerical Analysis Algorithms Utilities. */
#define  PI       3.141592653589793238462643383279502884197

char *outfile   = "simpson.out";            /* Default name of the output file. */
char *eq_text_f = "f(x) = sin(x)";          /* Needs updating  $.               */


/*****************************************************************************/
/* f(x) - Function to evaluate, f(x).  Needs updating $.                     */
/*****************************************************************************/
double f(x)
double x;
{
  return (sin(x));
}
/*****************************************************************************/


main()
{
  double a, b, h, X, XI, XI0, XI1, XI2, f();
  int i, n;

  /**********
   * INPUTS *
   **********/

  get_title();                     /* Prompts for optional comments. */

  printf("Composite Simpson's Rule - Algorithm 4.1\n\n");
  printf("%s\n\n", eq_text_f);

  printf("Enter endpoint a: ");
  scanf("%lf", &a);
  printf("Enter endpoint b: ");
  scanf("%lf", &b);

  do {
    printf("Enter number of intervals on [a,b], n: ");
    scanf("%d", &n);
    if (n <= 0)
      printf("ERROR - n must be greater than zero.\n");
  } while (n <= 0);

  /*************
   * ALGORITHM *
   *************/

  /* STEP #1 */
  h = (b - a)/n;

  /* STEP #2 */
  XI0 = f(a) + f(b);
  XI1 = 0.0;                       /* Summation of f(x(2i-1)). */
  XI2 = 0.0;                       /* Summation of f(x(2i)).   */

  /* STEP #3 */
  for (i=1;i<n;i++) {

    /* STEP #4 */
    X = a + i*h;

    /* STEP #5 */
    if (i % 2 == 0)
      XI2 += f(X);                 /* For even i. */
    else
      XI1 += f(X);                 /* For odd i.  */
  }

  /* STEP #6 */
  XI = h*(XI0 + 2.0*XI2 + 4.0*XI1) / 3.0;

  /***********
   * OUTPUTS *
   ***********/

  /* STEP #7 */
  /* Write output to the screen. */
  printf("Interval number h = %lg\n\n", h);
  printf("     Ù%lg\n", b);
  printf("XI = ≥  f(x) dx = %.11lg\n", XI);
  printf("     ı%lg\n\n", a);
  printf("Required %d functional evaluations.\n", n + 1);

  /* Write output to a file. */
  open_outfile(outfile);
  fprintf(file_id, "Composite Simpson's Rule - Algorithm 4.1\n\n");
  fprintf(file_id, "%s from %lg to %lg.\n\n", eq_text_f, a, b);
  fprintf(file_id, "n = %d intervals on [a,b].\n", n);
  fprintf(file_id, "Interval number h = %lg\n\n", h);
  fprintf(file_id, "     Ù%lg\n", b);
  fprintf(file_id, "XI = ≥  f(x) dx = %.11lg\n", XI);
  fprintf(file_id, "     ı%lg\n\n", a);
  fprintf(file_id, "Required %d functional evaluations.\n", n + 1);
  close_outfile(outfile);

  printf("\nOutput saved into file \"%s\".\n", outfile);

}                                  /* STOP */

/*****************************************************************************/
/*          Copyright (C) 1991, Harold A. Toomey, All Rights Reserved.        */
/*****************************************************************************/


         D.3.2    NAAUTIL.H

/******************************* NAAUTIL.H ************************************
               "Numerical Analysis Algorithms in C" Utilities I v4.0
******************************************************************************/

/*
**      Return   Procedure
**      Value    Name            Description
**      -----------------------------------------------------------------
**       void     naaerror      -  Exits a program with an error message
**       void     get_title     -  Prompts for an optional title
**       void     open_outfile  -  Opens the default output file
**       void     close_outfile -  Closes the default output file
*/

/***********/
/* DEFINES */
/***********/

/*
**  The ANSI FLAG below allows the user more flexibility when compiling and
**  running these Numerical Analysis Algorithms.  Set to TRUE first.  Older
**  C compilers may require it to be set to FALSE.  No adverse effects should
**  occur.
*/

#ifndef TRUE
#define TRUE      1                /* Define TRUE if not already defined.       */
#endif

#ifndef FALSE
#define FALSE     0                /* Define FALSE if not already defined.      */
#endif

#define  ANSI              TRUE    /* Set to TRUE if using an ANSI C standard   */
                                   /* compliant compiler (default).             */
                                   /* Set to FALSE if using an older C compiler.*/
                                   /* ANSI = American National Standards        */
                                   /*        Institute                          */

/*****************
 * INCLUDE FILES *
 *****************/

#include <math.h>                  /* For math function prototypes.             */
#include <stdio.h>                 /* For scanf(), printf() and fprintf().      */

#if ANSI == TRUE
#include <stdlib.h>                /* Needed for calloc() by some compilers and */
#endif                             /* for tolower().                            */


/********************
 * GLOBAL VARIABLES *
 ********************/

char title[133];                   /* Used in get_title() and print_title().    */
FILE *file_id;                     /* Stream used to save output into a file.   */


/***********************
 * FUNCTION PROTOTYPES *
 ***********************/

#if ANSI == TRUE
  /* ANSI STANDARD PROTOTYPING (Post-December 14, 1989)    */
  void     naaerror      (char []);
  void     get_title     (void);
  void     open_outfile  (char *);
  void     close_outfile (char *);
#else
  /* OLDER STYLE PROTOTYPING (Pre-December 14, 1989)       */
  /* Placed here for compatibility with older C compilers. */
  void     naaerror();
  void     get_title();
  void     open_outfile();
  void     close_outfile();
#endif


/***************
 * SUBROUTINES *
 ***************/

/*****************************************************************************/
/* naaerror() - Numerical Analysis Algorithms standard error handler.        */
/*****************************************************************************/
void naaerror(error_text)
char error_text[];
{
  fprintf(stderr,"\nNumerical Analysis Algorithms run-time error...\n");
  fprintf(stderr,"%s", error_text);
  fprintf(stderr,"\n...now exiting to system...\n");
  exit (1);
}

/*****************************************************************************/
/* get_title() - Prints the NAA banner and prompts for an optional title.    */
/*****************************************************************************/
void get_title()
{
  int i;

  /* Print the Numerical Analysis Algorithms banner. */
  for (i=1;i<80;i++)  printf("-");
  printf("\n\t\t\"Numerical Analysis Algorithms in C\" v4.0\n");
  for (i=1;i<80;i++)  printf("-");
  printf("\n");

  printf("Enter a title [ie - Set 2.1,  Problem 2 a) ].\n----> ");
  fgets(title, 133, stdin);
  printf("\n");
}

/*****************************************************************************/
/* open_outfile() - Opens the default output file and prints the NAA banner  */
/*                  and optional title.                                      */
/*****************************************************************************/
void open_outfile(outfile)
char *outfile;
{
  char msg[80];                    /* Holds an error message string */
  int i;

  /* Open the default output file. */
  if ((file_id = fopen(outfile, "w")) == NULL) {
    sprintf(msg, "Can not open the output file named \"%s\".", outfile);
    naaerror(msg);
  }

  /* Print the Numerical Analysis Algorithms banner. */
  for (i=1;i<80;i++)  fprintf(file_id, "-");
  fprintf(file_id, "\n\t\t\"Numerical Analysis Algorithms in C\" v4.0\n");
  for (i=1;i<80;i++)  fprintf(file_id, "-");
  fprintf(file_id, "\n\n");

  /* Print the optional title. */
  if (title[0] != '\n')
    fprintf(file_id, "%s\n", title);
}

/*****************************************************************************/
/* close_outfile() - Closes the default output file.                         */
/*****************************************************************************/
void close_outfile(outfile)
char *outfile;
{
  char msg[80];                    /* Holds an error message string */

  if (fclose(file_id) == EOF) {
    sprintf(msg, "Can not close the output file named \"%s\".", outfile);
    naaerror(msg);
  }
}

/*****************************************************************************/
/*       Written by:  Harold A. Toomey, CARE-FREE SOFTWARE, 2Q 1991, v4.0     */
/*       Copyright (C) 1991, Harold A. Toomey, All Rights Reserved.           */
/*****************************************************************************/


         D.3.3    SIMPSON.IN

NAA v4.0 Sample Output
0.0
3.14159265358979324
20


         D.3.4    SIMPSON.OUT

-------------------------------------------------------------------------------
                  "Numerical Analysis Algorithms in C" v4.0
-------------------------------------------------------------------------------

NAA v4.0 Sample Output

Composite Simpson's Rule - Algorithm 4.1

f(x) = sin(x) from 0 to 3.14159.

n = 20 intervals on [a,b].
Interval number h = 0.15708

     Ù3.14159
XI = ≥  f(x) dx = 2.0000067844
     ı0

Required 21 functional evaluations.
        D.4      C++


         D.4.1    SIMPSON.CPP

//
//  FILE NAME: SIMPSON.CPP
//  LANGUAGE:  C++
//  COMPILERS: Borland C++ or Turbo C++ 2.0
//  STATUS:    Not tested yet
//

/******************************************************************************
                  Composite Simpson's Rule - Algorithm 4.1
*******************************************************************************

                                Ùb
To approximate the integral I = ≥  f(x) dx:
                                ıa

INPUT endpoints a, b; positive integer n; the function f().

OUTPUT approximation XI to I.

*******************************************************************************
*        Written by:  Harold A. Toomey, CARE-FREE SOFTWARE, 2Q 1991, v4.2      *
******************************************************************************/

#include "simpson.hpp"             // Numerical Analysis Algorithms Utilities.
                                   // Also contains #include <iostream.h>.
#define  PI       3.141592653589793238462643383279502884197

char *outfile   = "simpson.out";            // Default name of the output file.
char *eq_text_f = "f(x) = sin(x)";          // Needs updating  $.

/***********************/
/* FUNCTION PROTOTYPES */
/***********************/

double f(double x);


/*****************************************************************************/
/* f(x) - Function to evaluate, f(x).  Needs updating $.                    */
/*****************************************************************************/
double f(double x)
{
  return (sin(x));
}
/*****************************************************************************/


void main(void)
{
  double a, b, h, X, XI, XI0, XI1, XI2, f();
  int i, n;

  /**********
   * INPUTS *
   **********/

  get_title();                     // Prompts for optional comments.

  cout << "Composite Simpson's Rule - Algorithm 4.1\n\n";
  cout << eq_text_f << "\n\n";

  cout << "Enter endpoint a: ";
  cin >> a;
  cout << "Enter endpoint b: ";
  cin >> b;

  do {
    cout << "Enter number of intervals on [a,b], n: ";
    cin >> n;
    if (n <= 0)
      cerr << "ERROR - n must be greater than zero.\n";
  } while (n <= 0);

  /*************
   * ALGORITHM *
   *************/

  /* STEP #1 */
  h = (b - a)/n;

  /* STEP #2 */
  XI0 = f(a) + f(b);
  XI1 = 0.0;                       // Summation of f(x(2i-1)).
  XI2 = 0.0;                       // Summation of f(x(2i)).

  /* STEP #3 */
  for (i=1;i<n;i++) {

    /* STEP #4 */
    X = a + i*h;

    /* STEP #5 */
    if (i % 2 == 0)
      XI2 += f(X);                 // For even i.
    else
      XI1 += f(X);                 // For odd i.
  }

  /* STEP #6 */
  XI = h*(XI0 + 2.0*XI2 + 4.0*XI1) / 3.0;

  /***********
   * OUTPUTS *
   ***********/

  /* STEP #7 */
  // Write output to the screen.
  cout << "Interval number h = " << h << "\n\n";
  cout << "     Ù" << b << "\n";
  cout << "XI = ≥  f(x) dx = " << XI << "\n";
  cout << "     ı" << a << "\n\n";
  cout << "Required " << n + 1 << " functional evaluations.\n";

  // Write output to a file.
  open_outfile(outfile);
  fprintf(file_id, "Composite Simpson's Rule - Algorithm 4.1\n\n");
  fprintf(file_id, "%s from %lg to %lg.\n\n", eq_text_f, a, b);
  fprintf(file_id, "n = %d intervals on [a,b].\n", n);
  fprintf(file_id, "Interval number h = %lg\n\n", h);
  fprintf(file_id, "     Ù%lg\n", b);
  fprintf(file_id, "XI = ≥  f(x) dx = %.11lg\n", XI);
  fprintf(file_id, "     ı%lg\n\n", a);
  fprintf(file_id, "Required %d functional evaluations.\n", n + 1);
  close_outfile(outfile);

  cout << "\nOutput saved into file \"" << outfile << "\".\n";

}                                  // STOP

/*****************************************************************************/
/*       Copyright (C) 1991, Harold A. Toomey, All Rights Reserved.           */
/*****************************************************************************/


         D.4.2    NAAUTIL.HPP

/****************************** NAAUTIL.HPP ***********************************
             "Numerical Analysis Algorithms in C++" Utilities I v4.0
******************************************************************************/

//
//      Return   Procedure
//      Value    Name            Description
//      -----------------------------------------------------------------
//       void     naaerror      -  Exits a program with an error message
//       void     get_title     -  Prompts for an optional title
//       void     open_outfile  -  Opens the default output file
//       void     close_outfile -  Closes the default output file
//


/*****************
 * INCLUDE FILES *
 *****************/

#include <stdio.h>                 // For fprintf().
#include <iostream.h>              // For cin, cout and cerr.
#include <stdlib.h>                // Needed for calloc() by some compilers and
                                   // for tolower().
#include <math.h>                  // For math function prototypes.


/********************
 * GLOBAL VARIABLES *
 ********************/

char title[133];                   // Used in get_title() and print_title().
FILE *file_id;                     // Stream used to save output into a file.


/***********************
 * FUNCTION PROTOTYPES *
 ***********************/

void naaerror      (char []);
void get_title     (void);
void open_outfile  (char *);
void close_outfile (char *);


/***************
 * SUBROUTINES *
 ***************/

/*****************************************************************************/
/* naaerror() - Numerical Analysis Algorithms standard error handler.        */
/*****************************************************************************/
void naaerror(char error_text[])
{
  cerr << "\nNumerical Analysis Algorithms run-time error...\n";
  cerr << error_text;
  cerr << "\n...now exiting to system...\n";
  exit (1);
}

/*****************************************************************************/
/* get_title() - Prints the NAA banner and prompts for an optional title.    */
/*****************************************************************************/
void get_title(void)
{
  int i;

  // Print the Numerical Analysis Algorithms banner.
  for (i=1;i<80;i++)  cout << "-";
  cout << "\n\t\t\"Numerical Analysis Algorithms in C++\" v4.0\n";
  for (i=1;i<80;i++)  cout << "-";
  cout << "\n";

  cout << "Enter an optional title [ie - Set 2.1,  Problem 2 a) ].\n----> ";
  fgets(title, 133, stdin);
  cout << "\n";
}

/*****************************************************************************/
/* open_outfile() - Opens the default output file and prints the NAA banner  */
/*                  and optional title.                                      */
/*****************************************************************************/
void open_outfile(char *outfile)
{
  char msg[80];                    // Holds an error message string.
  int i;

  // Open the default output file.
  if ((file_id = fopen(outfile, "w")) == NULL) {
    sprintf(msg, "Can not open the output file named \"%s\".", outfile);
    naaerror(msg);
  }

  // Print the Numerical Analysis Algorithms banner.
  for (i=1;i<80;i++)  fprintf(file_id, "-");
  fprintf(file_id, "\n\t\t\"Numerical Analysis Algorithms in C++\" v4.0\n");
  for (i=1;i<80;i++)  fprintf(file_id, "-");
  fprintf(file_id, "\n\n");

  // Print the optional title.
  if (title[0] != '\n')
    fprintf(file_id, "%s\n", title);
}

/*****************************************************************************/
/* close_outfile() - Closes the default output file.                         */
/*****************************************************************************/
void close_outfile(char *outfile)
{
  char msg[80];                    // Holds an error message string.

  if (fclose(file_id) == EOF) {
    sprintf(msg, "Can not close the output file named \"%s\".", outfile);
    naaerror(msg);
  }
}

/*****************************************************************************/
/*       Written by:  Harold A. Toomey, CARE-FREE SOFTWARE, 2Q 1991, v4.0     */
/*       Copyright (C) 1991, Harold A. Toomey, All Rights Reserved.           */
/*****************************************************************************/


         D.4.3    SIMPSON.IN

NAA v4.2 Sample Output
0.0
3.14159265358979324
20


         D.4.4    SIMPSON.OUT

-------------------------------------------------------------------------------
                  "Numerical Analysis Algorithms in C++" v4.0
-------------------------------------------------------------------------------

NAA v4.0 Sample Output

Composite Simpson's Rule - Algorithm 4.1

f(x) = sin(x) from 0 to 3.14159.

n = 2m = 20 subintervals of [a,b].
Interval number h = 0.15708

     Ù3.14159
XI = ≥  f(x) dx = 2.0000067844
     ı0

Required 21 functional evaluations.
        D.5      FORTRAN 77


         D.5.1    SIMPSON.FOR

C  FILE NAME: SIMPSON.FOR
C  LANGUAGE:  FORTRAN 77
C  COMPILER:  Microsoft FORTRAN 77 Version 3.3
C  STATUS:    Compiles and runs correctly
C
C *****************************************************************************
C                     Composite Simpson's Rule - Algorithm 4.1
C *****************************************************************************
C
C                                 Ùb
C To approximate the integral I = ≥  f(x) dx:
C                                 ıa
C
C INPUT endpoints a, b; positive integer n; the function f().
C
C OUTPUT approximation XI to I.
C
C *****************************************************************************
C        Written by:  Harold A. Toomey, CARE-FREE SOFTWARE, 2Q 1991, v4.0
C *****************************************************************************
C
C
      PROGRAM SIMPSON
C
      DOUBLE PRECISION A, B, H, X
      INTEGER OUT, I, N
      CHARACTER*80 TITLE
      CHARACTER*12 OUTFILE
C
C     -- OUT will be assigned to OUTFILE for printing to an output file
      PARAMETER (OUT=4)
C
C     -- Default name of the outfile
      DATA OUTFILE/'SIMPSON.OUT'/
C
C *****************************************************************************
C * F(X) - Function to evaluate, f(x).  Needs updating $.
C *****************************************************************************
C
      F(X) = DSIN(X)
C
C *****************************************************************************
C
C     **********
C     * INPUTS *
C     **********
C
C     -- Prompts for optional title
      WRITE (*,1)
      WRITE (*,2)
      WRITE (*,3)
      WRITE (*,*) ' Enter a title [ie - Set 2.1,  Problem 2 a) ].'
      WRITE (*,*) ' ----> '
      READ (*, 100) TITLE
100   FORMAT(A80)
      WRITE (*,4)
      WRITE (*,*) 'Enter endpoint a:'
      READ (*, 101) A
101   FORMAT(D8.0)
      WRITE (*,*) 'Enter endpoint b:'
      READ (*, 102) B
102   FORMAT(D8.0)
200   WRITE (*,*) 'Enter number of intervals on [a,b], n:'
      READ (*, 103) N
103   FORMAT(I8)
C
C     -- ERROR - n must be positive
      IF (N .LE. 0) THEN
        WRITE (*,*) 'ERROR - n must be greater than zero.'
        GOTO 200
      ENDIF
C
C     *************
C     * ALGORITHM *
C     *************
C
C     STEP #1
      H = (B - A) / N
C
C     STEP #2
      XI0 = F(A) + F(B)
C     -- Summation of f(x(2i-1))
      XI1 = 0.0
C     -- Summation of f(x(2i))
      XI2 = 0.0
C
C     STEP #3
      DO 50 I=1,N-1
C
C       STEP #4
        X = A + I*H
C
C       STEP #5
        IF (MOD(I,2) .EQ. 0) THEN
C         -- For I even
          XI2 = XI2 + F(X)
        ELSE
C         -- For I odd
          XI1 = XI1 + F(X)
        ENDIF
50    CONTINUE
C
C     STEP #6
      XI = H * (XI0 + 2*XI2 + 4*XI1) / 3.0
C
C     ***********
C     * OUTPUTS *
C     ***********
C
C     STEP #7
C     -- Write output to the screen (*) and to a file (OUT=4).
C     -- Open outfile for output
C     OPEN (OUT,FILE=OUTFILE,STATUS='UNKNOWN')
      OPEN (OUT,FILE=OUTFILE)
C
      WRITE (*,1)
      WRITE (OUT,1)
      WRITE (*,2)
      WRITE (OUT,2)
      WRITE (*,3)
      WRITE (OUT,3)
1     FORMAT(' ',78('-'))
2     FORMAT(' ',16X,'"Numerical Analysis Algorithms in FORTRAN" v4.0')
3     FORMAT(' ',78('-'),/)
      WRITE (*,*) TITLE
      WRITE (OUT,*) TITLE
      WRITE (*,4)
      WRITE (OUT,4)
4     FORMAT(' Composite Simpson`s Rule - Algorithm 4.1',/)
      WRITE (*,5) A, B
      WRITE (OUT,5) A, B
5     FORMAT(' f(x) = sin(x) from ',D12.7,' to ',D12.7,'.',/)
      WRITE (*,6) N
      WRITE (OUT,6) N
6     FORMAT(' n = ',I4,' intervals on [a,b].')
      WRITE (*,7) H
      WRITE (OUT,7) H
7     FORMAT(' Interval number h = ',D13.7/)
      WRITE (*,8) B
      WRITE (OUT,8) B
8     FORMAT('     Ù',D13.7)
      WRITE (*,9) XI
      WRITE (OUT,9) XI
9     FORMAT(' I = ≥  f(x) dx = ',D13.7)
      WRITE (*,10) A
      WRITE (OUT,10) A
10    FORMAT('     ı',D13.7/)
      WRITE (*,11) N + 1
      WRITE (OUT,11) N + 1
11    FORMAT(' Required ',I4,' functional evaluations.',/)
C
C     -- Closes outfile previously opened for output
      ENDFILE (OUT)
      CLOSE (OUT)
      WRITE (*,12) OUTFILE
12    FORMAT(' Output saved into file "', A, '".',/)
C
      END
C
C *****************************************************************************
C           Copyright (C) 1991, Harold A. Toomey, All Rights Reserved.
C *****************************************************************************


         D.5.2    SIMPSON.IN

NAA v4.0 Sample Output
0.0
3.14159265358979324
20


         D.5.3    SIMPSON.OUT

 ------------------------------------------------------------------------------
                 "Numerical Analysis Algorithms in FORTRAN" v4.0
 ------------------------------------------------------------------------------
 
 NAA 4.2 Sample Output                                                         

  
 Composite Simpson`s Rule - Algorithm 4.1
 
 f(x) = sin(x) from .0000000D+00 to .3141592D+01.
 
 n =   20 intervals on [a,b].
 Interval number h =  .1570796D+00
 
     Ù .3141592D+01
 I = ≥  f(x) dx =  .2000007D+01
     ı .0000000D+00
 
 Required   21 functional evaluations.
        D.6      Pascal


         D.6.1    SIMPSON.PAS

{
FILE NAME: SIMPSON.PAS
LANGUAGE:  PASCAL
COMPILER:  Turbo PASCAL Version 3.02A
STATUS:    Compiles and runs correctly
           Note: NAAMATH.INC has not been fully tested yet
}

{******************************************************************************
                  Composite Simpson's Rule - Algorithm 4.1
*******************************************************************************

                                Ùb
To approximate the integral I = ≥  f(x) dx:
                                ıa

INPUT endpoints a, b; positive integer n; the function f().

OUTPUT approximation XI to I.

*******************************************************************************
*        Written by:  Harold A. Toomey, CARE-FREE SOFTWARE, 2Q 1991, v4.0      *
******************************************************************************}

PROGRAM simpson;

{ USES TRANSCEND }                 { Un-comment if using UCSD Pascal. }

  TYPE
    STRING_TYPE = STRING[80];

  CONST
    PI = 3.1415926535897932384626433832795028841972;
    outfile = 'simpson.out';       { Default name of the output file. }
    eq_text_f = 'f(x) = sin(x)';{ Needs Updating $                 }

  VAR
    a, b, h, X, XI, XI0, XI1, XI2 : REAL;
    i, n    : INTEGER;
    title   : STRING_TYPE;
    file_id : TEXT;

  {****************************
   * PROCEDURES AND FUNCTIONS *
   ****************************}

  {$I NAAUTIL.INC}                 { Numerical Analysis Algorithms Utilities. }
  {$I NAAMATH.INC}                 { Complete set of math functions.          }


{*****************************************************************************
 * f(x) - Function to evaluate, f(x).  Needs updating $.                    *
 *****************************************************************************}
  FUNCTION f(x : REAL) : REAL;
  BEGIN
    f := SIN(x)
  END;


{*****************************************************************************
 *               THIS IS WHERE THE PROGRAM STARTS EXECUTING                  *
 *****************************************************************************}

BEGIN

  {**********
   * INPUTS *
   **********}

  title := get_title;              { Prompts for optional comments. }

  WRITELN ('Composite Simpson`s Rule - Algorithm 4.1');
  WRITELN;
  WRITELN (eq_text_f);
  WRITELN;
  WRITE ('Enter endpoint a: ');
  READLN (a);
  WRITE ('Enter endpoint b: ');
  READLN (b);

  REPEAT
    WRITE ('Enter number of intervals on [a,b], n: ');
    READLN (n);
    IF n <= 0 THEN
      WRITELN ('ERROR - n must be greater than zero.');
  UNTIL (n > 0);

  {*************
   * ALGORITHM *
   *************}

  { STEP #1 }
  h := (b - a)/n;

  { STEP #2 }
  XI0 := f(a) + f(b);
  XI1 := 0.0;                      { Summation of f(x(2i-1)). }
  XI2 := 0.0;                      { Summation of f(x(2i)).   }

  { STEP #3 }
  FOR i := 1 TO n - 1 DO
    BEGIN

      { STEP #4 }
      X := a + i*h;

      { STEP #5 }
      IF NOT ODD(i) THEN
        XI2 := XI2 + f(X)          { For even i. }
      ELSE
        XI1 := XI1 + f(X)          { For odd i.  }
    END;

  { STEP #6 }
  XI := h*(XI0 + 2.0*XI2 + 4.0*XI1) / 3.0;

  {***********
   * OUTPUTS *
   ***********}

  { STEP #7 }
  { Write output to the screen. }
  print_title (title);

  WRITELN ('Composite Simpson`s Rule - Algorithm 4.1');
  WRITELN;
  WRITELN (eq_text_f, ' from ', a :8:8, ' to ', b :8:8, '.');
  WRITELN;
  WRITELN ('n = ', n, ' intervals on [a,b].');
  WRITELN ('Interval number h = ', h :8:8);
  WRITELN;
  WRITELN ('    Ù', b :8:8);
  WRITELN ('I = ≥  f(x) dx = ', XI :8:8);
  WRITELN ('    ı', a :8:8);
  WRITELN;
  WRITELN ('Required ', n + 1, ' functional evaluations.');

  { Write output to a file. }
  ASSIGN (file_id, outfile);       { Opens outfile for output. }
  REWRITE (file_id);

  print_title_to_outfile (title);

  WRITELN (file_id);
  WRITELN (file_id, 'Composite Simpson`s Rule - Algorithm 4.1');
  WRITELN (file_id);
  WRITELN (file_id, eq_text_f, ' from ', a :8:8, ' to ', b :8:8, '.');
  WRITELN (file_id);
  WRITELN (file_id, 'n = ', n, ' intervals on [a,b].');
  WRITELN (file_id, 'Interval number h = ', h :8:8);
  WRITELN (file_id);
  WRITELN (file_id, '    Ù', b :8:8);
  WRITELN (file_id, 'I = ≥  f(x) dx = ', XI :8:8);
  WRITELN (file_id, '    ı', a :8:8);
  WRITELN (file_id);
  WRITELN (file_id, 'Required ', n + 1, ' functional evaluations.');
  CLOSE (file_id);                 { Closes output file. }

  WRITELN;
  WRITELN ('Output saved into file "', outfile, '".');

END.                               { STOP }

{******************************************************************************
*        Copyright (C) 1991, Harold A. Toomey, All Rights Reserved.            *
******************************************************************************}


         D.6.2    NAAUTIL.INC

(****************************** NAAUTIL.INC ***********************************
         "Numerical Analysis Algorithms in Pascal" Utilities I v4.0
******************************************************************************)
(*
This include file contains many useful procedures used by most all of the
Numerical Analysis Algorithms programs.  It should be included in all of the
programs using the line {$I NAAUTIL.INC}.  It contains the following
procedures and functions:

         PROCEDURE naaerror               (str     : STRING_TYPE);
         FUNCTION  get_title                       : STRING_TYPE;
         PROCEDURE print_title            (str     : STRING_TYPE);
         PROCEDURE print_title_to_outfile (str     : STRING_TYPE);

*)

(*****************************************************************************
 * naaerror() - Numerical Analysis Algorithms standard error handler.        *
 *****************************************************************************)
PROCEDURE naaerror(str : STRING_TYPE);
BEGIN
  WRITELN;
  WRITELN('Numerical Analysis Algorithms run-time error...');
  WRITELN(str);
  WRITELN('...now exiting to system...');
  HALT
END;

(*****************************************************************************
 * get_title() - Prints the NAA banner and prompts for an optional title.    *
 *****************************************************************************)
FUNCTION get_title : STRING_TYPE;
VAR
  str : STRING_TYPE;
BEGIN
  FOR i := 1 TO 79 DO
    WRITE('-');
  WRITELN;
  WRITE('                 ');
  WRITELN('"Numerical Analysis Algorithms in Pascal" v4.0');
  FOR i := 1 TO 79 DO
    WRITE('-');
  WRITELN;
  WRITELN;
  WRITELN('Enter a title [ie - Set 2.1,  Problem 2 a) ].');
  WRITE('----> ');
  READLN(str);
  WRITELN;
  get_title := str
END;

(*****************************************************************************
 * print_title() - Prints the optional title to the screen.                  *
 *****************************************************************************)
PROCEDURE print_title(str : STRING_TYPE);
VAR
  i : INTEGER;
BEGIN
  FOR i := 1 TO 79 DO
    WRITE('-');
  WRITELN;
  WRITE('                 ');
  WRITELN('"Numerical Analysis Algorithms in Pascal" v4.0');
  FOR i := 1 TO 79 DO
    WRITE('-');
  WRITELN;
  WRITELN;

  IF LENGTH(str) > 1 THEN
    WRITELN(str);
  WRITELN
END;

(*****************************************************************************
 * print_title_to_outfile() - Prints the optional title to a file.           *
 *****************************************************************************)
PROCEDURE print_title_to_outfile(str : STRING_TYPE);
VAR
  i : INTEGER;
BEGIN
  FOR i := 1 TO 79 DO
    WRITE (file_id, '-');
  WRITELN (file_id);
  WRITE   (file_id, '                 ');
  WRITELN (file_id, '"Numerical Analysis Algorithms in Pascal" v4.0');
  FOR i := 1 TO 79 DO
    WRITE (file_id, '-');
  WRITELN (file_id);
  WRITELN (file_id);

  IF LENGTH(str) > 1 THEN
    WRITELN (file_id, str);
END;

(******************************************************************************
*        Written by:  Harold A. Toomey, CARE-FREE SOFTWARE, 2Q 1991, v4.0      *
*        Copyright (C) 1991, Harold A. Toomey, All Rights Reserved.            *
******************************************************************************)


         D.6.3    NAAMATH.INC

Too long to list here.  "Naamath.inc" contains a complete set of mathematical
functions left out of the Pascal language.


         D.6.4    SIMPSON.IN

NAA v4.0 Sample Output
0.0
3.14159265358979
20


         D.6.5    SIMPSON.OUT

-------------------------------------------------------------------------------
                 "Numerical Analysis Algorithms in Pascal" v4.0
-------------------------------------------------------------------------------

NAA 4.0 Sample Output

Composite Simpson`s Rule - Algorithm 4.1

f(x) = sin(x) from 0.00000000 to 3.14159200.

n = 20 subintervals of [a,b].
Interval number h = 0.15707960

    Ù3.14159200
I = ≥  f(x) dx = 2.00000678
    ı0.00000000

Required 21 functional evaluations.INDEX


